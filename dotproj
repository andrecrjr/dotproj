#!/bin/bash

# DotProj CLI - Manages project-specific dotfiles with Git versioning

CONFIG_FILE="$HOME/.dotproj/config"
DOTFILES_ROOT="$HOME/.dotproj/projects"
CMD="$1"
PROJECT="$2"

mkdir -p "$DOTFILES_ROOT"

# Check if Git is available
check_git() {
  if ! command -v git >/dev/null 2>&1; then
    echo "❌ Error: Git is required but not installed."
    echo ""
    echo "📦 Please install Git first:"
    echo "  • Ubuntu/Debian: sudo apt update && sudo apt install git"
    echo "  • CentOS/RHEL:   sudo yum install git"
    echo "  • Fedora:        sudo dnf install git"
    echo "  • macOS:         brew install git (or install Xcode Command Line Tools)"
    echo "  • Arch Linux:    sudo pacman -S git"
    echo ""
    echo "DotProj requires Git for version control and synchronization."
    exit 1
  fi
}

# Check Git configuration and provide setup guidance
check_git_config() {
  local git_name
  local git_email
  
  git_name=$(git config --global user.name 2>/dev/null || echo "")
  git_email=$(git config --global user.email 2>/dev/null || echo "")
  
  if [ -z "$git_name" ] || [ -z "$git_email" ]; then
    echo "⚠️  Git is not fully configured for commits."
    echo ""
    echo "🔧 Please configure Git with your name and email:"
    echo "   git config --global user.name \"Your Name\""
    echo "   git config --global user.email \"your.email@example.com\""
    echo ""
    echo "This is required for Git commits and synchronization."
    echo ""
    echo -n "Continue anyway? (y/N): "
    read -r continue_choice
    if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
      echo "Setup cancelled. Please configure Git and try again."
      exit 1
    fi
    echo ""
  fi
}

get_relative_path() {
  local file="$1"
  local project_path="$2"
  echo "${file#$project_path/}"
}

prompt_dotfiles_selection() {
  local project_path="$1"
  local project="$2"
  
  echo ""
  echo "📁 Dotfiles Selection for '$project'"
  echo "════════════════════════════════════════════════════════════════"
  echo "Enter the files/dotfiles/folders you want to track (comma-separated):"
  echo ""
  echo "🔒 SECURITY REMINDER: Ensure your Git repo is PRIVATE for sensitive files!"
  echo ""
  echo "Examples:"
  echo "  .env.local, monorepo/front-end/.cursor, monorepo/back-end/.env"
  echo "  .cursor, .cursor/rules/, .vscode/mcp.json, .vscode/settings.json, .vscode/extensions.json"
  echo ""
  echo "💡 Tips:"
  echo "  - Use relative paths from your project root"
  echo "  - Folders will include all files within them"
  echo "  - You can add more dotfiles later with 'dotproj add <project>'"
  echo "  - ⚠️  Files with secrets (.env) require PRIVATE repositories!"
  echo ""
  echo -n "Enter dotfiles to track (or press Enter to skip): "
  read -r dotfiles_input
  
  if [ -n "$dotfiles_input" ]; then
    echo "$dotfiles_input" | tr ',' '\n' | while IFS= read -r item; do
      item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      
      if [ -n "$item" ]; then
        full_path="$project_path/$item"
        
        if [ -e "$full_path" ]; then
          if [ -d "$full_path" ]; then
            find "$full_path" -type f | while IFS= read -r file; do
              link_dotfile "$file" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
              rel_path=$(get_relative_path "$file" "$project_path")
              echo "  ✅ Added: $rel_path"
            done
          else
            link_dotfile "$full_path" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
            echo "  ✅ Added: $item"
          fi
        else
          echo "  ⚠️  Warning: $item not found in project directory"
        fi
      fi
    done
  else
    echo "  ℹ️  No dotfiles selected. You can add them later with 'dotproj add <project>'"
  fi
}

is_tracked() {
  local file="$1"
  local project="$2"
  local dotfiles_dir="$DOTFILES_ROOT/$project/dotfiles"
  local tracked_file="$dotfiles_dir/$file"
  
  [ -f "$tracked_file" ]
}

link_dotfile() {
  local src_file="$1"
  local dest_dir="$2"
  local project_path="$3"
  
  local rel_path
  rel_path=$(get_relative_path "$src_file" "$project_path")
  local dest_file="$dest_dir/$rel_path"
  
  mkdir -p "$(dirname "$dest_file")"
  cp "$src_file" "$dest_file"
}

create_symlink() {
  local stored_file="$1"
  local target_file="$2"
  local rel_path="$3"
  local project_dir="$4"
  
  # Create backup if target exists and is not already a symlink to our stored file
  if [ -e "$target_file" ]; then
    if [ -L "$target_file" ]; then
      # Check if it's already pointing to our stored file
      if [ "$(readlink "$target_file")" = "$stored_file" ]; then
        return 0  # Already correctly linked
      else
        # Symlink pointing elsewhere, back it up
        local backup_dir="$project_dir/backups"
        mkdir -p "$backup_dir"
        local backup_file="$backup_dir/${rel_path//\//_}.backup"
        
        # Remove existing backup if it exists, then create new one
        [ -e "$backup_file" ] && rm -f "$backup_file"
        mv "$target_file" "$backup_file"
        echo "    📦 Updated backup for symlink: $rel_path -> backups/${backup_file##*/}"
      fi
    else
      # Regular file, back it up
      local backup_dir="$project_dir/backups"
      mkdir -p "$backup_dir"
      local backup_file="$backup_dir/${rel_path//\//_}.backup"
      
      # Remove existing backup if it exists, then create new one
      [ -e "$backup_file" ] && rm -f "$backup_file"
      cp "$target_file" "$backup_file"
      rm "$target_file"
      echo "    📦 Updated backup for file: $rel_path -> backups/${backup_file##*/}"
    fi
  fi
  
  # Create the symlink
  ln -s "$stored_file" "$target_file"
}

ensure_gitignore() {
  local project_dir="$1"
  local gitignore_file="$project_dir/.gitignore"
  
  # Create .gitignore if it doesn't exist
  if [ ! -f "$gitignore_file" ]; then
    touch "$gitignore_file"
  fi
  
  # Add backups directory to .gitignore if not already there
  if ! grep -q "^backups/" "$gitignore_file" 2>/dev/null; then
    echo "" >> "$gitignore_file"
    echo "# DotProj backup files" >> "$gitignore_file"
    echo "backups/" >> "$gitignore_file"
    echo "  ℹ️  Added backups/ to .gitignore"
  fi
}

usage() {
  echo "DotProj CLI - Manage project-specific dotfiles"
  echo "Usage: dotproj <command> [project]"
  echo "Commands:"
  echo "  setup               Install DotProj and add to PATH"
  echo "  init <project>      Initialize dotfiles for a project"
  echo "  clone <project>     Clone from a remote repository and commit dotfiles"
  echo "  add <project>       Add more dotfiles to an existing project"
  echo "  commit <project>    Apply dotfiles as symlinks to the current environment"
  echo "  status <project>    Show tracked and excluded dotfiles for a project"
  echo "  push <project>      Commit and push dotfiles to Git repository"
  echo "  pull <project>      Pull latest dotfiles from Git repository"
  echo "  remove <project>    Remove a project and all its dotfiles"
  echo "  list                List all projects"
  echo "  version             Show version and system information"
  echo "  update              Check for and install DotProj updates"
  echo "Use 'dotproj <command> --help' for more details"
  exit 1
}

get_version() {
  local script_dir
  script_dir="$(dirname "$(readlink -f "$0")")"
  
  # Try to read from VERSION file in the same directory as the script
  if [ -f "$script_dir/VERSION" ]; then
    cat "$script_dir/VERSION"
  elif [ -f "$HOME/.dotproj/VERSION" ]; then
    cat "$HOME/.dotproj/VERSION"
  else
    # Fallback to hardcoded version
    echo "1.0.0"
  fi
}

check_for_updates() {
  local current_version="$1"
  local check_only="${2:-false}"
  
  if command -v curl >/dev/null 2>&1; then
    echo ""
    echo "🔍 Checking for updates..."
    
    # Try to get latest version from GitHub
    local latest_version
    latest_version=$(curl -s "https://raw.githubusercontent.com/andrecrjr/dotproj/master/VERSION" 2>/dev/null || echo "")
    
    if [ -n "$latest_version" ] && [ "$latest_version" != "$current_version" ]; then
      echo "📦 Update available: $current_version → $latest_version"
      echo ""
      if [ "$check_only" = "false" ]; then
        echo "💡 To update DotProj, run:"
        echo "   bash <(curl -fsSL https://raw.githubusercontent.com/andrecrjr/dotproj/master/update.sh)"
        echo ""
        echo "   Or download the update script:"
        echo "   curl -fsSL https://raw.githubusercontent.com/andrecrjr/dotproj/master/update.sh -o update.sh"
        echo "   chmod +x update.sh && ./update.sh"
      fi
    elif [ -n "$latest_version" ]; then
      if [ "$check_only" = "true" ]; then
        echo "✅ DotProj is up to date (version $current_version)"
      fi
    else
      if [ "$check_only" = "true" ]; then
        echo "⚠️  Could not check for updates (network issue or repository unavailable)"
      fi
    fi
  else
    if [ "$check_only" = "true" ]; then
      echo "⚠️  curl not available - cannot check for updates"
    fi
  fi
}

version() {
  local current_version
  current_version=$(get_version)
  
  echo "🎯 DotProj - Project-Specific Dotfiles Manager"
  echo "Version: $current_version"
  echo ""
  echo "📋 System Information:"
  echo "  OS: $(uname -s)"
  echo "  Shell: $SHELL"
  if command -v git >/dev/null 2>&1; then
    echo "  Git: $(git --version)"
    local git_name git_email
    git_name=$(git config --global user.name 2>/dev/null || echo "Not configured")
    git_email=$(git config --global user.email 2>/dev/null || echo "Not configured")
    echo "  Git User: $git_name <$git_email>"
  else
    echo "  Git: ❌ Not installed"
  fi
  echo ""
  echo "📁 DotProj Paths:"
  echo "  Config: $CONFIG_FILE"
  echo "  Storage: $DOTFILES_ROOT"
  
  # Check for updates
  check_for_updates "$current_version" "false"
}

command_help() {
  local cmd="$1"
  case "$cmd" in
    setup)
      echo "dotproj setup: Installs DotProj and adds it to PATH"
      echo "Adds ~/.dotproj/dotproj.sh to ~/.bashrc or ~/.zshrc"
      ;;
    init)
      echo "dotproj init <project>: Initializes files/dotfiles for a project"
      echo "Creates project storage and prompts for files/dotfiles selection"
      echo "Prompts for project path and optional Git repo"
      ;;
    clone)
      echo "dotproj clone <project>: Clone from a remote repository"
      echo "Clones the repository to dotproj storage and commits files/dotfiles to current directory"
      echo "Usage: dotproj clone <project> [git-repo-url]"
      echo "If no URL provided, will prompt for repository URL"
      echo "If multiple branches exist, you can choose which one to restore from"
      ;;
    add)
      echo "dotproj add <project>: Add more files/dotfiles to an existing project"
      echo "Allows you to track additional dotfiles using comma-separated input"
      ;;
    commit)
      echo "dotproj commit <project>: Apply files/dotfiles to the environment"
      echo "Creates symlinks from project locations to stored dotfiles"
      echo "Similar to 'git commit' - applies your tracked changes"
      ;;
    status)
      echo "dotproj status <project>: Shows tracked files/dotfiles for a project"
      echo "Displays which files are being managed"
      ;;
    push)
      echo "dotproj push <project>: Push files/dotfiles to Git repository"
      echo "Commits local changes and pushes to remote repo (if configured)"
      echo "Similar to 'git push' - syncs your changes to remote"
      ;;
    pull)
      echo "dotproj pull <project>: Pull latest files/dotfiles from Git repository"
      echo "Fetches and merges changes from remote repo (if configured)"
      echo "Similar to 'git pull' - gets latest changes from remote"
      echo "If multiple remote branches exist, you can choose which one to pull from"
      ;;
    remove)
      echo "dotproj remove <project>: Remove a project and all its files/dotfiles"
      echo "Permanently deletes the project storage directory"
      ;;
    list)
      echo "dotproj list: Lists all initialized projects"
      ;;
    version)
      echo "dotproj version: Shows version and system information"
      echo "Displays DotProj version, Git status, and configuration paths"
      echo "Use 'dotproj update' to check for updates"
      ;;
    update)
      echo "dotproj update: Check for and install DotProj updates"
      echo "Downloads and runs the update script to install the latest version"
      echo "Options:"
      echo "  --check    Only check for updates without installing"
      echo "  --force    Force update even if already up to date"
      ;;
    *)
      usage
      ;;
  esac
  exit 0
}

check_project() {
  if [ -z "$PROJECT" ]; then
    echo "Error: Project name required"
    usage
  fi
}

get_project_config() {
  local project="$1"
  local key="$2"
  if [ -f "$CONFIG_FILE" ]; then
    grep "^$project:$key:" "$CONFIG_FILE" | cut -d':' -f3-
  fi
}

write_config() {
  local project="$1"
  local key="$2"
  local value="$3"
  mkdir -p "$(dirname "$CONFIG_FILE")"
  if [ -f "$CONFIG_FILE" ]; then
    grep -v "^$project:$key:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" || true
    mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  fi
  echo "$project:$key:$value" >> "$CONFIG_FILE"
}

setup() {
  check_git
  
  # Create dotproj directory
  mkdir -p "$HOME/.dotproj"
  
  # Install the script with proper naming
  if [ -f "$HOME/.dotproj/dotproj" ]; then
    echo "DotProj already installed at ~/.dotproj/dotproj"
  else
    echo "Installing DotProj to ~/.dotproj/dotproj..."
    cp "$0" "$HOME/.dotproj/dotproj"
    chmod +x "$HOME/.dotproj/dotproj"
  fi
  
  # Install VERSION file if it exists alongside the script
  local script_dir
  script_dir="$(dirname "$(readlink -f "$0")")"
  if [ -f "$script_dir/VERSION" ] && [ ! -f "$HOME/.dotproj/VERSION" ]; then
    echo "Installing version information..."
    cp "$script_dir/VERSION" "$HOME/.dotproj/VERSION"
  fi

  # Install update.sh if it exists alongside the script
  if [ -f "$script_dir/update.sh" ] && [ ! -f "$HOME/.dotproj/update.sh" ]; then
    echo "Installing update script..."
    cp "$script_dir/update.sh" "$HOME/.dotproj/update.sh"
  fi

  # Add to PATH if not already there
  shell_file="$HOME/.bashrc"
  [ -f "$HOME/.zshrc" ] && shell_file="$HOME/.zshrc"
  
  if ! grep -q "PATH.*\.dotproj" "$shell_file"; then
    echo "Adding DotProj to PATH in $shell_file..."
    echo '' >> "$shell_file"
    echo '# DotProj - Project-specific dotfiles manager' >> "$shell_file"
    echo 'export PATH="$HOME/.dotproj:$PATH"' >> "$shell_file"
    echo "✅ Added to PATH. Please restart your terminal or run: source $shell_file"
  else
    echo "✅ DotProj already in PATH"
  fi
  
  echo "🎉 Setup complete! Run 'dotproj --help' for available commands"
}

init() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' already exists in $project_dir"
    exit 1
  fi

  echo "Enter project path (default: $PWD):"
  read -r project_path
  project_path="${project_path:-$PWD}"
  if [ ! -d "$project_path" ]; then
    echo "Error: Directory $project_path does not exist"
    exit 1
  fi

  echo ""
  echo "🔗 Git Repository (Required)"
  echo "═══════════════════════════════════════════════════════════════"
  echo "Enter Git repository URL to sync your dotfiles across machines:"
  echo ""
  echo "🔒 SECURITY WARNING: Use PRIVATE repositories for sensitive files!"
  echo "   • .env files with API keys/secrets → PRIVATE REPO REQUIRED"
  echo "   • Team configurations with secrets → PRIVATE REPO REQUIRED"
  echo "   • Public configs (.vscode settings) → Public repos OK"
  echo ""
  echo "Examples:"
  echo "  https://github.com/username/my-project-config.git (PRIVATE)"
  echo "  git@gitlab.com:username/project-dotfiles.git (PRIVATE)"
  echo "  https://bitbucket.org/username/project-config.git (PRIVATE)"
  echo ""

  while true; do
    echo -n "Git repo URL: "
    read -r git_repo

    if [ -z "$git_repo" ]; then
      echo "Error: Git repository URL is required"
      continue
    fi

    if git ls-remote "$git_repo" >/dev/null 2>&1; then
      break
    else
      echo "Error: Invalid Git repository URL"
    fi
  done

  echo "Creating project structure..."
  mkdir -p "$project_dir/dotfiles"

  echo "Initializing Git repo..."
  cd "$project_dir" || exit 1
  git init -q
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  git checkout -q -b "$branch_name"
  
  git add .
  git commit -q -m "Initial files/dotfiles for $PROJECT"

  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  write_config "$PROJECT" "branch" "$branch_name"
  [ -n "$git_repo" ] && write_config "$PROJECT" "git" "$git_repo"
  echo "Initialized project '$PROJECT' in $project_dir"

  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  cd "$project_dir" || exit 1
  git add .
  git commit -q -m "Add selected files/dotfiles for $PROJECT"
}

clone() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo="$3"

  if [ -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' already exists in $project_dir"
    exit 1
  fi

  # Get Git repository URL if not provided
  if [ -z "$git_repo" ]; then
    echo ""
    echo "🌐 Remote Repository Setup"
    echo "═══════════════════════════════════════════════════════════════"
    echo "Enter the Git repository URL containing the files/dotfiles:"
    echo ""
    echo "🔒 SECURITY WARNING: Ensure repository is PRIVATE for sensitive files!"
    echo "   • .env files with API keys/secrets → PRIVATE REPO REQUIRED"
    echo "   • Team configurations with secrets → PRIVATE REPO REQUIRED"
    echo "   • Public configs (.vscode settings) → Public repos OK"
    echo ""
    echo "Examples:"
    echo "  https://github.com/username/my-project-config.git (PRIVATE)"
    echo "  git@github.com:username/project-dotfiles.git (PRIVATE)"
    echo "  https://gitlab.com/username/project-config.git (PRIVATE)"
    echo ""
    echo -n "Git repo URL: "
    read -r git_repo
    
    if [ -z "$git_repo" ]; then
      echo "Error: Git repository URL is required"
      exit 1
    fi
  fi

  # Use current directory as project path
  local project_path="$PWD"

  echo ""
  echo "🎯 Cloning '$PROJECT' from remote repository..."
  echo "Repository: $git_repo"
  echo "Project path: $project_path"
  echo "════════════════════════════════════════════════════════════════"

  echo "📥 Cloning repository to dotproj storage..."
  
  # Clone directly to the dotproj storage directory
  if ! git clone "$git_repo" "$project_dir" 2>/dev/null; then
    echo "❌ Failed to clone repository: $git_repo"
    echo ""
    echo "Please check:"
    echo "  - Repository URL is correct"
    echo "  - You have access to the repository"
    echo "  - Repository exists and is accessible"
    echo "  - Your internet connection is working"
    echo "  - Git is properly configured with credentials (if private repo)"
    exit 1
  fi

  echo "✅ Repository cloned successfully!"

  # Switch to project-specific branch or let user choose
  cd "$project_dir" || exit 1
  local branch_name="dotproj-$PROJECT"
  local selected_branch=""
  
  echo "🔀 Setting up project branch..."
  
  # Get all available branches (both local and remote)
  local all_branches
  all_branches=$(git branch -a 2>/dev/null | sed 's/^[* ] //' | sed 's/remotes\/origin\///' | grep -v '^HEAD' | sort -u | grep -v '^$' || echo "")
  
  # Always show branch selection if there are any branches
  if [ -n "$all_branches" ]; then
    echo ""
    echo "📋 Available branches in repository:"
    echo "════════════════════════════════════════════════════════════════"
    
    local i=1
    local temp_file=$(mktemp)
    echo "$all_branches" > "$temp_file"
    
    while IFS= read -r branch; do
      if [ -n "$branch" ]; then
        # Check if this is a dotproj branch
        if [[ "$branch" == dotproj-* ]]; then
          echo "  $i) $branch ⭐ (DotProj branch)"
        else
          echo "  $i) $branch"
        fi
        i=$((i + 1))
      fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo ""
    echo "💡 Choose a branch to restore configuration from:"
    echo "   • DotProj branches (⭐) contain project-specific configurations"
    echo "   • Other branches may contain different setups or shared configs"
    echo ""
    
    # Loop until valid selection is made
    while true; do
      echo -n "Select branch number (required): "
      read -r branch_choice
      
      if [ -n "$branch_choice" ] && [ "$branch_choice" -gt 0 ] 2>/dev/null; then
        selected_branch=$(echo "$all_branches" | sed -n "${branch_choice}p")
        if [ -n "$selected_branch" ]; then
          echo "  ✅ Selected branch: $selected_branch"
          branch_name="$selected_branch"
          break
        else
          echo "  ❌ Invalid selection. Please choose a number from the list above."
          echo ""
        fi
      else
        echo "  ❌ Please enter a valid number from the list above."
        echo ""
      fi
    done
  else
    echo "  ⚠️  No branches found in repository. Using default: $branch_name"
  fi
  
  echo "🔀 Setting up project branch: $branch_name"
  
  # Check if the selected branch exists on remote
  if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
    echo "  📥 Checking out existing remote branch: $branch_name"
    git checkout -q "$branch_name"
  elif git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "  🔄 Switching to existing local branch: $branch_name"
    git checkout -q "$branch_name"
  else
    # Get the default branch (could be main, master, etc.)
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "")
    
    if [ -z "$default_branch" ]; then
      # Fallback: try to determine default branch from available branches
      default_branch=$(git branch -r | grep -E 'origin/(main|master)' | head -1 | sed 's@.*origin/@@' | tr -d ' ' || echo "")
    fi
    
    if [ -z "$default_branch" ]; then
      # Final fallback: use current branch
      default_branch=$(git branch --show-current 2>/dev/null || echo "main")
    fi
    
    echo "  🆕 Creating new project branch: $branch_name (from $default_branch)"
    git checkout -q -b "$branch_name" "$default_branch" 2>/dev/null || git checkout -q -b "$branch_name"
  fi

  # Write configuration
  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  write_config "$PROJECT" "git" "$git_repo"
  write_config "$PROJECT" "branch" "$branch_name"

  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"

  echo ""
  echo "🎯 Repository cloned and branch '$branch_name' selected!"
  echo ""
  echo "💡 Next steps:"
  echo "   1. Review the files in the selected branch"
  echo "   2. Run 'dotproj commit $PROJECT' to apply files as symlinks"
  echo "   3. Or run 'dotproj status $PROJECT' to see what will be applied"
  echo ""
  echo -n "Apply files from '$branch_name' to current project now? (y/N): "
  read -r apply_now
  
  if [ "$apply_now" = "y" ] || [ "$apply_now" = "Y" ]; then
    echo ""
    echo "🔗 Committing files/dotfiles to current project..."
    
    # Apply all files from the repository as symlinks
    local dotfiles_applied=0
    find "$project_dir" -type f -not -path "*/.git/*" -not -name ".gitignore" | while IFS= read -r stored_file; do
      # Calculate relative path from project_dir
      rel_path="${stored_file#$project_dir/}"
      
      # Skip dotfiles directory prefix if it exists
      if [[ "$rel_path" == dotfiles/* ]]; then
        rel_path="${rel_path#dotfiles/}"
      fi
      
      target_file="$project_path/$rel_path"
      
      mkdir -p "$(dirname "$target_file")"
      create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
      echo "    🔗 Committed: $rel_path"
      dotfiles_applied=$((dotfiles_applied + 1))
    done

    if [ $dotfiles_applied -eq 0 ]; then
      echo "  ⚠️  No files found to commit from the repository"
    fi

    echo ""
    echo "🎉 Clone and commit complete!"
  else
    echo ""
    echo "🎉 Clone complete!"
    echo "   Files are ready in branch '$branch_name'"
    echo "   Run 'dotproj commit $PROJECT' when ready to apply them"
  fi
  echo ""
  echo "💡 Project details:"
  echo "   Name:    $PROJECT"
  echo "   Storage: $project_dir"
  echo "   Target:  $project_path"
  echo "   Remote:  $git_repo"
  echo ""
  echo "📋 Available commands:"
  echo "   dotproj status $PROJECT    - Show committed files"
  echo "   dotproj add $PROJECT       - Add more files"
  echo "   dotproj commit $PROJECT    - Apply any new files as symlinks"
  echo "   dotproj push $PROJECT      - Push changes to remote"
  echo "   dotproj pull $PROJECT      - Pull changes from remote"
}

add() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    echo "Run 'dotproj init $PROJECT' first to create the project"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    exit 1
  fi

  echo "🔄 Adding files/dotfiles to existing project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  
  echo "Currently tracked files/dotfiles:"
  if [ -d "$project_dir/dotfiles" ] && [ "$(find "$project_dir/dotfiles" -type f | wc -l)" -gt 0 ]; then
    find "$project_dir/dotfiles" -type f | while IFS= read -r file; do
      rel_path="${file#$project_dir/dotfiles/}"
      echo "  ✅ $rel_path"
    done
  else
    echo "  (none)"
  fi
  
  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  # Create symlinks for newly added files
  local dotfiles_dir="$project_dir/dotfiles"
  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo ""
    echo "🔗 Committing newly added files/dotfiles..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      # Only create symlink if target doesn't exist or isn't already correctly linked
      if [ ! -L "$target_file" ] || [ "$(readlink "$target_file" 2>/dev/null)" != "$stored_file" ]; then
        mkdir -p "$(dirname "$target_file")"
        create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
        echo "    🔗 Committed: $rel_path"
      fi
    done
  fi
  
  cd "$project_dir" || exit 1
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    git checkout -q "$branch_name" 2>/dev/null || git checkout -q -b "$branch_name"
  fi
  
  git add .
  git commit -q -m "Add new files/dotfiles to $PROJECT" 2>/dev/null || echo "No new files to commit"
  
  echo ""
  echo "✅ Successfully added and committed files/dotfiles to '$PROJECT'"
}

remove() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "🗑️  Remove Project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  echo "This will permanently delete:"
  echo "  - Project storage: $project_dir"
  echo "  - All tracked files/dotfiles for this project"
  echo "  - Configuration entries"
  echo ""
  echo "⚠️  Warning: This action cannot be undone!"
  echo ""
  echo -n "Are you sure you want to remove project '$PROJECT'? (type 'yes' to confirm): "
  read -r confirmation

  if [ "$confirmation" = "yes" ]; then
    rm -rf "$project_dir"
    
    if [ -f "$CONFIG_FILE" ]; then
      grep -v "^$PROJECT:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" 2>/dev/null || true
      mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE" 2>/dev/null || rm -f "${CONFIG_FILE}.tmp"
    fi
    
    echo "✅ Project '$PROJECT' has been successfully removed"
  else
    echo "❌ Project removal cancelled"
  fi
}

commit() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    echo "Set path with 'dotproj init $PROJECT' or edit $CONFIG_FILE"
    exit 1
  fi

  echo "📋 Committing files/dotfiles for '$PROJECT'..."

  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "  Creating symlinks for tracked dotfiles..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      mkdir -p "$(dirname "$target_file")"
      
      create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
      echo "    🔗 Committed: $rel_path -> $stored_file"
    done
  else
    echo "  ℹ️  No files/dotfiles are currently tracked for this project"
    echo "    Use 'dotproj add $PROJECT' to track some files/dotfiles first"
  fi
  
  echo "✅ Committed files/dotfiles for '$PROJECT'"
  echo "✅ Configuration applied and symlinked to your project"
}

push() {
  check_project
  check_git
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")
  local branch_name="${stored_branch:-dotproj-$PROJECT}"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "🚀 Pushing files/dotfiles for '$PROJECT'..."
  cd "$project_dir" || exit 1
  
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      echo "  Switching to branch: $branch_name"
      git checkout -q "$branch_name"
    else
      echo "  Creating and switching to branch: $branch_name"
      git checkout -q -b "$branch_name"
    fi
  fi

  echo "  Staging changes..."
  git add .
  if git commit -q -m "Push dotfiles for $PROJECT - $(date '+%Y-%m-%d %H:%M:%S')" 2>/dev/null; then
    echo "  ✅ Changes committed locally"
  else
    echo "  ℹ️  No changes to commit"
  fi

  if [ -n "$git_repo" ]; then
    echo "  🌐 Pushing to remote repository..."
    
    if ! git remote get-url origin >/dev/null 2>&1; then
      echo "  Setting up remote: $git_repo"
      git remote add origin "$git_repo"
    fi

    echo "  Pushing to remote..."
    if git push origin "$branch_name" 2>/dev/null; then
      echo "  ✅ Successfully pushed to remote"
    else
      echo "  ⚠️  Push failed. You may need to pull first to resolve conflicts."
      echo "     Try: dotproj pull $PROJECT"
    fi
  else
    echo "  ℹ️  No remote Git repo configured, local commit only"
    echo "     Set Git repo during 'dotproj init $PROJECT' or edit $CONFIG_FILE"
  fi
  
  echo "✅ Push completed for '$PROJECT'"
}

pull() {
  check_project
  check_git
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")
  local branch_name="${stored_branch:-dotproj-$PROJECT}"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$git_repo" ]; then
    echo "Error: No remote Git repository configured for project '$PROJECT'"
    echo "Configure during 'dotproj init $PROJECT' or edit $CONFIG_FILE"
    exit 1
  fi

  echo "📥 Pulling files/dotfiles for '$PROJECT'..."
  cd "$project_dir" || exit 1
  
  # Check if there are multiple remote branches available
  local remote_branches
  remote_branches=$(git branch -r 2>/dev/null | sed 's/^[* ] //' | sed 's/origin\///' | grep -v '^HEAD' | sort -u | grep -v '^$' || echo "")
  local remote_branch_count
  remote_branch_count=$(echo "$remote_branches" | wc -l)
  
  # If there are multiple branches, let user choose which one to pull from
  if [ "$remote_branch_count" -gt 1 ] && [ -n "$remote_branches" ]; then
    echo ""
    echo "📋 Available remote branches:"
    echo "════════════════════════════════════════════════════════════════"
    
    local i=1
    local temp_file=$(mktemp)
    echo "$remote_branches" > "$temp_file"
    
    while IFS= read -r branch; do
      if [ -n "$branch" ]; then
        # Check if this is a dotproj branch
        if [[ "$branch" == dotproj-* ]]; then
          echo "  $i) $branch ⭐ (DotProj branch)"
        else
          echo "  $i) $branch"
        fi
        i=$((i + 1))
      fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo ""
    echo "💡 Choose a branch to pull from:"
    echo "   • DotProj branches (⭐) contain project-specific configurations"
    echo "   • Other branches may contain different setups or shared configs"
    echo ""
    
    # Loop until valid selection is made or user chooses default
    while true; do
      echo -n "Select branch number (or press Enter for current '$branch_name'): "
      read -r branch_choice
      
      if [ -z "$branch_choice" ]; then
        echo "  ℹ️  Using current branch: $branch_name"
        break
      elif [ "$branch_choice" -gt 0 ] 2>/dev/null; then
        local selected_branch
        selected_branch=$(echo "$remote_branches" | sed -n "${branch_choice}p")
        if [ -n "$selected_branch" ]; then
          echo "  ✅ Selected branch: $selected_branch"
          branch_name="$selected_branch"
          # Update stored branch configuration
          write_config "$PROJECT" "branch" "$branch_name"
          break
        else
          echo "  ❌ Invalid selection. Please choose a number from the list above or press Enter for default."
          echo ""
        fi
      else
        echo "  ❌ Please enter a valid number from the list above or press Enter for default."
        echo ""
      fi
    done
  fi
  
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      echo "  Switching to branch: $branch_name"
      git checkout -q "$branch_name"
    else
      echo "  Creating and switching to branch: $branch_name"
      git checkout -q -b "$branch_name"
    fi
  fi

  echo "  Fetching from remote..."
  if git fetch origin 2>/dev/null; then
    if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
      echo "  Merging with remote branch: $branch_name"
      if git merge "origin/$branch_name" --no-edit -q 2>/dev/null; then
        echo "  ✅ Successfully pulled from remote"
        
        # After successful pull, ask if user wants to commit the changes
        echo ""
        echo "💡 Changes pulled successfully. Apply them to your project?"
        echo -n "Run 'dotproj commit $PROJECT' now? (y/N): "
        read -r apply_choice
        if [ "$apply_choice" = "y" ] || [ "$apply_choice" = "Y" ]; then
          echo ""
          commit
        else
          echo "  ℹ️  Run 'dotproj commit $PROJECT' when ready to apply changes"
        fi
      else
        echo "  ⚠️  Merge conflict detected. Please resolve manually:"
        echo "     cd $project_dir"
        echo "     git status"
        echo "     # Resolve conflicts, then:"
        echo "     git add ."
        echo "     git commit"
        echo "     dotproj commit $PROJECT"
        return 1
      fi
    else
      echo "  ⚠️  Remote branch '$branch_name' not found"
      echo "     The remote repository may not have this project branch yet"
      echo "     Try: dotproj push $PROJECT"
    fi
  else
    echo "  ❌ Failed to fetch from remote"
    echo "     Please check your repository access and internet connection"
    return 1
  fi
  
  echo "✅ Pull completed for '$PROJECT'"
}

status() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "📊 Status for project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  echo "Project path: $project_path"
  echo "Storage path: $project_dir"
  [ -n "$git_repo" ] && echo "Git repo: $git_repo" || echo "Git repo: (not configured)"
  [ -n "$stored_branch" ] && echo "Git branch: $stored_branch" || echo "Git branch: dotproj-$PROJECT (default)"
  echo ""

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "📁 Tracked dotfiles:"
    find "$dotfiles_dir" -type f | while IFS= read -r file; do
      rel_path="${file#$dotfiles_dir/}"
      echo "  ✅ $rel_path"
    done
  else
    echo "📁 No dotfiles are currently tracked."
    echo "    Use 'dotproj add $PROJECT' to add some dotfiles."
  fi

  echo ""
  echo "💡 Available commands:"
  echo "    dotproj add $PROJECT       - Add more dotfiles"
  echo "    dotproj commit $PROJECT    - Apply dotfiles as symlinks to project"
  echo "    dotproj push $PROJECT      - Push changes to Git repository"
  echo "    dotproj pull $PROJECT      - Pull latest changes from Git repository"
}

list() {
  if [ -f "$CONFIG_FILE" ]; then
    echo "Available projects:"
    grep '^[^:]*:dotfiles:' "$CONFIG_FILE" | cut -d':' -f1 | sort -u | while read -r proj; do
      echo "- $proj"
    done
  else
    echo "No projects found. Run 'dotproj init <project>' to create one."
  fi
}

update() {
  local check_only=false
  local force_update=false
  
  # Parse options
  while [[ $# -gt 0 ]]; do
    case $1 in
      --check)
        check_only=true
        shift
        ;;
      --force)
        force_update=true
        shift
        ;;
      *)
        echo "Unknown option: $1"
        echo "Use 'dotproj update --help' for usage information"
        exit 1
        ;;
    esac
  done
  
  if [ "$check_only" = "true" ]; then
    local current_version
    current_version=$(get_version)
    echo "🔍 Checking for DotProj updates..."
    echo "Current version: $current_version"
    check_for_updates "$current_version" "true"
    return
  fi
  
  echo "🔄 DotProj Update Manager"
  echo "════════════════════════════════════════════════════════════════"
  echo ""
  
  # Check if curl is available
  if ! command -v curl >/dev/null 2>&1; then
    echo "❌ curl is required for updates but not installed."
    echo ""
    echo "📦 Please install curl first:"
    echo "  • Ubuntu/Debian: sudo apt update && sudo apt install curl"
    echo "  • CentOS/RHEL:   sudo yum install curl"
    echo "  • Fedora:        sudo dnf install curl"
    echo "  • macOS:         curl is usually pre-installed"
    echo "  • Arch Linux:    sudo pacman -S curl"
    echo ""
    echo "After installing curl, run 'dotproj update' again."
    exit 1
  fi
  
  echo "📥 Downloading update script..."
  local temp_script
  temp_script=$(mktemp)
  
  if ! curl -fsSL "https://raw.githubusercontent.com/andrecrjr/dotproj/master/update.sh" -o "$temp_script"; then
    echo "❌ Failed to download update script"
    echo ""
    echo "Please check:"
    echo "  - Your internet connection"
    echo "  - Repository availability"
    echo "  - Try again later"
    rm -f "$temp_script"
    exit 1
  fi
  
  chmod +x "$temp_script"
  
  echo "🚀 Running update script..."
  echo ""
  
  # Run the update script with appropriate flags
  if [ "$force_update" = "true" ]; then
    "$temp_script" --force
  else
    "$temp_script"
  fi
  
  # Clean up
  rm -f "$temp_script"
}

case "$CMD" in
  setup)
    [ "$2" = "--help" ] && command_help setup
    setup
    ;;
  init)
    [ "$2" = "--help" ] && command_help init
    init
    ;;
  clone)
    [ "$2" = "--help" ] && command_help clone
    clone
    ;;
  add)
    [ "$2" = "--help" ] && command_help add
    add
    ;;
  commit)
    [ "$2" = "--help" ] && command_help commit
    commit
    ;;
  status)
    [ "$2" = "--help" ] && command_help status
    status
    ;;
  push)
    [ "$2" = "--help" ] && command_help push
    push
    ;;
  pull)
    [ "$2" = "--help" ] && command_help pull
    pull
    ;;
  remove)
    [ "$2" = "--help" ] && command_help remove
    remove
    ;;
  list)
    [ "$2" = "--help" ] && command_help list
    list
    ;;
  version)
    version
    ;;
  update)
    [ "$2" = "--help" ] && command_help update
    shift  # Remove 'update' from arguments
    update "$@"
    ;;
  # Legacy command support with deprecation warnings
  apply)
    echo "⚠️  DEPRECATED: 'apply' command is deprecated. Use 'commit' instead."
    echo "   Running 'dotproj commit $PROJECT'..."
    echo ""
    commit
    ;;
  sync)
    echo "⚠️  DEPRECATED: 'sync' command is deprecated. Use 'push' instead."
    echo "   Running 'dotproj push $PROJECT'..."
    echo ""
    push
    ;;
  remote)
    echo "⚠️  DEPRECATED: 'remote' command is deprecated. Use 'clone' instead."
    echo "   Running 'dotproj clone $PROJECT'..."
    echo ""
    clone
    ;;
  save)
    echo "⚠️  DEPRECATED: 'save' command is deprecated."
    echo "   With symlinks, changes are automatically saved."
    echo "   Use 'dotproj status $PROJECT' to check file integrity."
    echo ""
    status
    ;;
  --help)
    usage
    ;;
  *)
    usage
    ;;
esac