#!/bin/bash

# DotProj CLI - Manages project-specific dotfiles with Git versioning

# Color constants for better UX
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

CONFIG_FILE="$HOME/.dotproj/config"
DOTFILES_ROOT="$HOME/.dotproj/projects"
CMD="$1"
PROJECT="$2"

mkdir -p "$DOTFILES_ROOT"

# Check if Git is available
check_git() {
  if ! command -v git >/dev/null 2>&1; then
    echo -e "${RED}❌ Error: Git is required but not installed.${NC}"
    echo ""
    echo -e "${BLUE}📦 Please install Git first:${NC}"
    echo "  • Ubuntu/Debian: sudo apt update && sudo apt install git"
    echo "  • CentOS/RHEL:   sudo yum install git"
    echo "  • Fedora:        sudo dnf install git"
    echo "  • macOS:         brew install git (or install Xcode Command Line Tools)"
    echo "  • Arch Linux:    sudo pacman -S git"
    echo ""
    echo "DotProj requires Git for version control and synchronization."
    exit 1
  fi
}

# Check Git configuration and provide setup guidance
check_git_config() {
  local git_name
  local git_email
  
  git_name=$(git config --global user.name 2>/dev/null || echo "")
  git_email=$(git config --global user.email 2>/dev/null || echo "")
  
  if [ -z "$git_name" ] || [ -z "$git_email" ]; then
    echo -e "${YELLOW}⚠️  Git is not fully configured for commits.${NC}"
    echo ""
    echo -e "${BLUE}🔧 Please configure Git with your name and email:${NC}"
    echo -e "   ${CYAN}git config --global user.name \"Your Name\"${NC}"
    echo -e "   ${CYAN}git config --global user.email \"your.email@example.com\"${NC}"
    echo ""
    echo "This is required for Git commits and synchronization."
    echo ""
    echo -n "Continue anyway? (y/N): "
    read -r continue_choice
    if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
      echo -e "${RED}Setup cancelled. Please configure Git and try again.${NC}"
      exit 1
    fi
    echo ""
  fi
}

# Check for uncommitted and unpushed changes
check_project_changes() {
  local project_dir="$1"
  local show_warnings="${2:-true}"
  
  if [ ! -d "$project_dir" ]; then
    return 0
  fi
  
  cd "$project_dir" || return 0
  
  # Check if git repo exists
  if [ ! -d ".git" ]; then
    return 0
  fi
  
  local has_uncommitted=false
  local has_unpushed=false
  local current_branch
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  
  # Check for uncommitted changes
  if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
    has_uncommitted=true
  fi
  
  # Check for unpushed changes (only if we have a current branch)
  if [ -n "$current_branch" ]; then
    # Check if remote branch exists
    if git show-ref --verify --quiet "refs/remotes/origin/$current_branch"; then
      # Compare local vs remote
      local local_commits remote_commits
      local_commits=$(git rev-list "origin/$current_branch..$current_branch" 2>/dev/null | wc -l)
      if [ "$local_commits" -gt 0 ]; then
        has_unpushed=true
      fi
    else
      # No remote branch exists, so local commits are unpushed
      local total_commits
      total_commits=$(git rev-list --count "$current_branch" 2>/dev/null || echo "0")
      if [ "$total_commits" -gt 0 ]; then
        has_unpushed=true
      fi
    fi
  fi
  
  # Show warnings if requested
  if [ "$show_warnings" = "true" ]; then
    if [ "$has_uncommitted" = "true" ]; then
      echo -e "${RED}⚠️  You have uncommitted changes in your dotfiles${NC}"
      echo -e "   Run '${CYAN}dotproj push $PROJECT${NC}' to commit and push them"
    fi
    
    if [ "$has_unpushed" = "true" ]; then
      echo -e "${RED}⚠️  You have unpushed dotfiles changes${NC}"
      echo -e "   Run '${CYAN}dotproj push $PROJECT${NC}' to push them to remote repository"
    fi
  fi
  
  # Return status: 0 = no changes, 1 = uncommitted, 2 = unpushed, 3 = both
  local status=0
  [ "$has_uncommitted" = "true" ] && status=$((status + 1))
  [ "$has_unpushed" = "true" ] && status=$((status + 2))
  return $status
}

get_relative_path() {
  local file="$1"
  local project_path="$2"
  echo "${file#$project_path/}"
}

prompt_dotfiles_selection() {
  local project_path="$1"
  local project="$2"
  
  echo ""
  echo "📁 Dotfiles Selection for '$project'"
  echo "════════════════════════════════════════════════════════════════"
  echo "Enter the files/dotfiles/folders you want to track (comma-separated):"
  echo ""
  echo "🔒 SECURITY REMINDER: Ensure your Git repo is PRIVATE for sensitive files!"
  echo ""
  echo "Examples:"
  echo "  .env.local, monorepo/front-end/.cursor, monorepo/back-end/.env"
  echo "  .cursor, .cursor/rules/, .vscode/mcp.json, .vscode/settings.json, .vscode/extensions.json"
  echo ""
  echo "💡 Tips:"
  echo "  - Use relative paths from your project root"
  echo "  - Folders will include all files within them"
  echo "  - You can add more dotfiles later with 'dotproj add <project>'"
  echo "  - ⚠️  Files with secrets (.env) require PRIVATE repositories!"
  echo ""
  echo -n "Enter dotfiles to track (or press Enter to skip): "
  read -r dotfiles_input
  
  if [ -n "$dotfiles_input" ]; then
    echo "$dotfiles_input" | tr ',' '\n' | while IFS= read -r item; do
      item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      
      if [ -n "$item" ]; then
        full_path="$project_path/$item"
        
        if [ -e "$full_path" ]; then
          if [ -d "$full_path" ]; then
            find "$full_path" -type f | while IFS= read -r file; do
              link_dotfile "$file" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
              rel_path=$(get_relative_path "$file" "$project_path")
              echo "  ✅ Added: $rel_path"
            done
          else
            link_dotfile "$full_path" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
            echo "  ✅ Added: $item"
          fi
        else
          echo "  ⚠️  Warning: $item not found in project directory"
        fi
      fi
    done
  else
    echo "  ℹ️  No dotfiles selected. You can add them later with 'dotproj add <project>'"
  fi
}

is_tracked() {
  local file="$1"
  local project="$2"
  local dotfiles_dir="$DOTFILES_ROOT/$project/dotfiles"
  local tracked_file="$dotfiles_dir/$file"
  
  [ -f "$tracked_file" ]
}

link_dotfile() {
  local src_file="$1"
  local dest_dir="$2"
  local project_path="$3"
  
  local rel_path
  rel_path=$(get_relative_path "$src_file" "$project_path")
  local dest_file="$dest_dir/$rel_path"
  
  mkdir -p "$(dirname "$dest_file")"
  cp "$src_file" "$dest_file"
}

create_symlink() {
  local stored_file="$1"
  local target_file="$2"
  local rel_path="$3"
  local project_dir="$4"
  
  # Create backup if target exists and is not already a symlink to our stored file
  if [ -e "$target_file" ]; then
    if [ -L "$target_file" ]; then
      # Check if it's already pointing to our stored file
      if [ "$(readlink "$target_file")" = "$stored_file" ]; then
        return 0  # Already correctly linked
      else
        # Symlink pointing elsewhere, back it up
        local backup_dir="$project_dir/backups"
        mkdir -p "$backup_dir"
        local backup_file="$backup_dir/${rel_path//\//_}.backup"
        
        # Remove existing backup if it exists, then create new one
        [ -e "$backup_file" ] && rm -f "$backup_file"
        mv "$target_file" "$backup_file"
        echo "    📦 Updated backup for symlink: $rel_path -> backups/${backup_file##*/}"
      fi
    else
      # Regular file, back it up
      local backup_dir="$project_dir/backups"
      mkdir -p "$backup_dir"
      local backup_file="$backup_dir/${rel_path//\//_}.backup"
      
      # Remove existing backup if it exists, then create new one
      [ -e "$backup_file" ] && rm -f "$backup_file"
      cp "$target_file" "$backup_file"
      rm "$target_file"
      echo "    📦 Updated backup for file: $rel_path -> backups/${backup_file##*/}"
    fi
  fi
  
  # Create the symlink
  ln -s "$stored_file" "$target_file"
}

ensure_gitignore() {
  local project_dir="$1"
  local gitignore_file="$project_dir/.gitignore"
  
  # Create .gitignore if it doesn't exist
  if [ ! -f "$gitignore_file" ]; then
    touch "$gitignore_file"
  fi
  
  # Add backups directory to .gitignore if not already there
  if ! grep -q "^backups/" "$gitignore_file" 2>/dev/null; then
    echo "" >> "$gitignore_file"
    echo "# DotProj backup files" >> "$gitignore_file"
    echo "backups/" >> "$gitignore_file"
    echo "  ℹ️  Added backups/ to .gitignore"
  fi
}

usage() {
  echo "DotProj CLI - Manage project-specific dotfiles"
  echo "Usage: dotproj <command> [project]"
  echo "Commands:"
  echo "  setup               Install DotProj and add to PATH"
  echo "  init <project>      Initialize dotfiles for a project"
  echo "  clone <project>     Clone from a remote repository and commit dotfiles"
  echo "  add [project]       Add more dotfiles to an existing project"
  echo "  commit [project]    Apply dotfiles as symlinks to the current environment"
  echo "  status [project]    Show tracked and excluded dotfiles for a project"
  echo "  push [project]      Commit and push dotfiles to Git repository"
  echo "  pull [project]      Pull latest dotfiles from Git repository"
  echo "  remove <project>    Remove a project and all its dotfiles"
  echo "  list                List projects for current directory"
  echo "  list all            List all projects and their paths"
  echo "  version             Show version and system information"
  echo "Use 'dotproj <command> --help' for more details"
  exit 1
}

get_version() {
  local script_dir
  script_dir="$(dirname "$(readlink -f "$0")")"
  
  # Try to read from VERSION file in the same directory as the script
  if [ -f "$script_dir/VERSION" ]; then
    cat "$script_dir/VERSION"
  elif [ -f "$HOME/.dotproj/VERSION" ]; then
    cat "$HOME/.dotproj/VERSION"
  else
    # Fallback to hardcoded version
    echo "1.0.0"
  fi
}

version() {
  local current_version
  current_version=$(get_version)
  
  echo "🎯 DotProj - Project-Specific Dotfiles Manager"
  echo "Version: $current_version"
  echo ""
  echo "📋 System Information:"
  echo "  OS: $(uname -s)"
  echo "  Shell: $SHELL"
  if command -v git >/dev/null 2>&1; then
    echo "  Git: $(git --version)"
    local git_name git_email
    git_name=$(git config --global user.name 2>/dev/null || echo "Not configured")
    git_email=$(git config --global user.email 2>/dev/null || echo "Not configured")
    echo "  Git User: $git_name <$git_email>"
  else
    echo "  Git: ❌ Not installed"
  fi
  echo ""
  echo "📁 DotProj Paths:"
  echo "  Config: $CONFIG_FILE"
  echo "  Storage: $DOTFILES_ROOT"
}

command_help() {
  local cmd="$1"
  case "$cmd" in
    setup)
      echo "dotproj setup: Installs DotProj and adds it to PATH"
      echo "Adds ~/.dotproj/dotproj.sh to ~/.bashrc or ~/.zshrc"
      ;;
    init)
      echo "dotproj init <project>: Initializes files/dotfiles for a project"
      echo "Creates project storage and prompts for files/dotfiles selection"
      echo "Prompts for project path and optional Git repo"
      ;;
    clone)
      echo "dotproj clone <project>: Clone from a remote repository"
      echo "Clones the repository to dotproj storage and commits files/dotfiles to current directory"
      echo "Usage: dotproj clone <project> [git-repo-url]"
      echo "If no URL provided, will prompt for repository URL"
      echo "If multiple branches exist, you can choose which one to restore from"
      ;;
    add)
      echo "dotproj add [project]: Add more files/dotfiles to an existing project"
      echo "Allows you to track additional dotfiles using comma-separated input"
      echo "If no project specified, auto-detects from current directory"
      ;;
    commit)
      echo "dotproj commit [project]: Apply files/dotfiles to the environment"
      echo "Creates symlinks from project locations to stored dotfiles"
      echo "Similar to 'git commit' - applies your tracked changes"
      echo "If no project specified, auto-detects from current directory"
      ;;
    status)
      echo "dotproj status [project]: Shows tracked files/dotfiles for a project"
      echo "Displays which files are being managed"
      echo "If no project specified, auto-detects from current directory"
      ;;
    push)
      echo "dotproj push [project]: Push files/dotfiles to Git repository"
      echo "Commits local changes and pushes to remote repo (if configured)"
      echo "Similar to 'git push' - syncs your changes to remote"
      echo "If no project specified, auto-detects from current directory"
      ;;
    pull)
      echo "dotproj pull [project]: Pull latest files/dotfiles from Git repository"
      echo "Fetches and merges changes from remote repo (if configured)"
      echo "Similar to 'git pull' - gets latest changes from remote"
      echo "If multiple remote branches exist, you can choose which one to pull from"
      echo "If no project specified, auto-detects from current directory"
      ;;
    remove)
      echo "dotproj remove <project>: Remove a project and all its files/dotfiles"
      echo "Permanently deletes the project storage directory"
      ;;
    list)
      echo "dotproj list: Lists projects configured for current directory"
      echo "dotproj list all: Lists all projects and their paths"
      ;;
    version)
      echo "dotproj version: Shows version and system information"
      echo "Displays DotProj version, Git status, and configuration paths"
      ;;
    *)
      usage
      ;;
  esac
  exit 0
}

get_current_directory_projects() {
  local current_dir="$PWD"
  local projects=""
  
  if [ ! -f "$CONFIG_FILE" ]; then
    return 1
  fi
  
  while IFS= read -r line; do
    if [[ "$line" == *":dotfiles:"* ]]; then
      local proj
      proj=$(echo "$line" | cut -d':' -f1)
      local proj_path
      proj_path=$(get_project_config "$proj" "path")
      if [ "$proj_path" = "$current_dir" ]; then
        if [ -z "$projects" ]; then
          projects="$proj"
        else
          projects="$projects,$proj"
        fi
      fi
    fi
  done < "$CONFIG_FILE"
  
  echo "$projects"
}

check_project() {
  if [ -z "$PROJECT" ]; then
    local current_projects
    current_projects=$(get_current_directory_projects)
    
    if [ -z "$current_projects" ]; then
      echo "❌ No projects found in current directory ($PWD)"
      echo "💡 Available options:"
      echo "   • Run 'dotproj init <project>' to create a new project"
      echo "   • Run 'dotproj list all' to see all projects"
      echo "   • Navigate to a directory with existing projects"
      exit 1
    fi
    
    # Count projects (count commas + 1)
    local project_count
    project_count=$(echo "$current_projects" | tr ',' '\n' | wc -l)
    
    if [ "$project_count" -eq 1 ]; then
      PROJECT="$current_projects"
      echo "🎯 Auto-detected project: $PROJECT"
    else
      echo "📋 Multiple projects found in current directory:"
      echo "$current_projects" | tr ',' '\n' | nl -w2 -s') '
      echo ""
      echo -n "Select project number: "
      read -r choice
      
      if [ -n "$choice" ] && [ "$choice" -gt 0 ] && [ "$choice" -le "$project_count" ]; then
        PROJECT=$(echo "$current_projects" | tr ',' '\n' | sed -n "${choice}p")
        echo "✅ Selected project: $PROJECT"
      else
        echo "❌ Invalid selection"
        exit 1
      fi
    fi
  fi
}

get_project_config() {
  local project="$1"
  local key="$2"
  if [ -f "$CONFIG_FILE" ]; then
    grep "^$project:$key:" "$CONFIG_FILE" | cut -d':' -f3-
  fi
}

write_config() {
  local project="$1"
  local key="$2"
  local value="$3"
  mkdir -p "$(dirname "$CONFIG_FILE")"
  if [ -f "$CONFIG_FILE" ]; then
    grep -v "^$project:$key:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" || true
    mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  fi
  echo "$project:$key:$value" >> "$CONFIG_FILE"
}

setup() {
  check_git
  
  # Create dotproj directory
  mkdir -p "$HOME/.dotproj"
  
  # Install the script with proper naming
  if [ -f "$HOME/.dotproj/dotproj" ]; then
    echo "DotProj already installed at ~/.dotproj/dotproj"
  else
    echo "Installing DotProj to ~/.dotproj/dotproj..."
    cp "$0" "$HOME/.dotproj/dotproj"
    chmod +x "$HOME/.dotproj/dotproj"
  fi
  
  # Install VERSION file if it exists alongside the script
  local script_dir
  script_dir="$(dirname "$(readlink -f "$0")")"
  if [ -f "$script_dir/VERSION" ] && [ ! -f "$HOME/.dotproj/VERSION" ]; then
    echo "Installing version information..."
    cp "$script_dir/VERSION" "$HOME/.dotproj/VERSION"
  fi

  # Add to PATH if not already there
  shell_file="$HOME/.bashrc"
  [ -f "$HOME/.zshrc" ] && shell_file="$HOME/.zshrc"
  
  if ! grep -q "PATH.*\.dotproj" "$shell_file"; then
    echo "Adding DotProj to PATH in $shell_file..."
    echo '' >> "$shell_file"
    echo '# DotProj - Project-specific dotfiles manager' >> "$shell_file"
    echo 'export PATH="$HOME/.dotproj:$PATH"' >> "$shell_file"
    echo "✅ Added to PATH. Please restart your terminal or run: source $shell_file"
  else
    echo "✅ DotProj already in PATH"
  fi
  
  echo -e "${GREEN}🎉 Setup complete! Run '${CYAN}dotproj --help${NC}${GREEN}' for available commands${NC}"
}

init() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ -d "$project_dir" ]; then
    echo -e "${RED}Error: Project '$PROJECT' already exists in $project_dir${NC}"
    exit 1
  fi

  echo "Enter project path (default: $PWD):"
  read -r project_path
  project_path="${project_path:-$PWD}"
  if [ ! -d "$project_path" ]; then
    echo "Error: Directory $project_path does not exist"
    exit 1
  fi

  echo ""
  echo "🔗 Git Repository (Required)"
  echo "═══════════════════════════════════════════════════════════════"
  echo "Enter Git repository URL to sync your dotfiles across machines:"
  echo ""
  echo "🔒 SECURITY WARNING: Use PRIVATE repositories for sensitive files!"
  echo "   • .env files with API keys/secrets → PRIVATE REPO REQUIRED"
  echo "   • Team configurations with secrets → PRIVATE REPO REQUIRED"
  echo "   • Public configs (.vscode settings) → Public repos OK"
  echo ""
  echo "Examples:"
  echo "  https://github.com/username/my-project-config.git (PRIVATE)"
  echo "  git@gitlab.com:username/project-dotfiles.git (PRIVATE)"
  echo "  https://bitbucket.org/username/project-config.git (PRIVATE)"
  echo ""

  while true; do
    echo -n "Git repo URL: "
    read -r git_repo

    if [ -z "$git_repo" ]; then
          echo -e "${RED}Error: Git repository URL is required${NC}"
    continue
    fi

    if git ls-remote "$git_repo" >/dev/null 2>&1; then
      break
    else
      echo -e "${RED}Error: Invalid Git repository URL${NC}"
    fi
  done

  echo "Creating project structure..."
  mkdir -p "$project_dir/dotfiles"

  echo "Initializing Git repo..."
  cd "$project_dir" || exit 1
  git init -q
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  git checkout -q -b "$branch_name"
  
  git add .
  git commit -q -m "Initial files/dotfiles for $PROJECT"

  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  write_config "$PROJECT" "branch" "$branch_name"
  [ -n "$git_repo" ] && write_config "$PROJECT" "git" "$git_repo"
  echo "Initialized project '$PROJECT' in $project_dir"

  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  cd "$project_dir" || exit 1
  git add .
  git commit -q -m "Add selected files/dotfiles for $PROJECT"
}

clone() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo="$3"

  if [ -d "$project_dir" ]; then
    echo -e "${RED}Error: Project '$PROJECT' already exists in $project_dir${NC}"
    exit 1
  fi

  # Get Git repository URL if not provided
  if [ -z "$git_repo" ]; then
    echo ""
    echo "🌐 Remote Repository Setup"
    echo "═══════════════════════════════════════════════════════════════"
    echo "Enter the Git repository URL containing the files/dotfiles:"
    echo ""
    echo "🔒 SECURITY WARNING: Ensure repository is PRIVATE for sensitive files!"
    echo "   • .env files with API keys/secrets → PRIVATE REPO REQUIRED"
    echo "   • Team configurations with secrets → PRIVATE REPO REQUIRED"
    echo "   • Public configs (.vscode settings) → Public repos OK"
    echo ""
    echo "Examples:"
    echo "  https://github.com/username/my-project-config.git (PRIVATE)"
    echo "  git@github.com:username/project-dotfiles.git (PRIVATE)"
    echo "  https://gitlab.com/username/project-config.git (PRIVATE)"
    echo ""
    echo -n "Git repo URL: "
    read -r git_repo
    
    if [ -z "$git_repo" ]; then
      echo "Error: Git repository URL is required"
      exit 1
    fi
  fi

  # Use current directory as project path
  local project_path="$PWD"

  echo ""
  echo "🎯 Cloning '$PROJECT' from remote repository..."
  echo "Repository: $git_repo"
  echo "Project path: $project_path"
  echo "════════════════════════════════════════════════════════════════"

  echo "📥 Cloning repository to dotproj storage..."
  
  # Clone directly to the dotproj storage directory
  if ! git clone "$git_repo" "$project_dir" 2>/dev/null; then
    echo "❌ Failed to clone repository: $git_repo"
    echo ""
    echo "Please check:"
    echo "  - Repository URL is correct"
    echo "  - You have access to the repository"
    echo "  - Repository exists and is accessible"
    echo "  - Your internet connection is working"
    echo "  - Git is properly configured with credentials (if private repo)"
    exit 1
  fi

  echo -e "${GREEN}✅ Repository cloned successfully!${NC}"

  # Switch to project-specific branch or let user choose
  cd "$project_dir" || exit 1
  local branch_name="dotproj-$PROJECT"
  local selected_branch=""
  
  echo "🔀 Setting up project branch..."
  
  # Get all available branches (both local and remote)
  local all_branches
  all_branches=$(git branch -a 2>/dev/null | sed 's/^[* ] //' | sed 's/remotes\/origin\///' | grep -v '^HEAD' | sort -u | grep -v '^$' || echo "")
  
  # Always show branch selection if there are any branches
  if [ -n "$all_branches" ]; then
    echo ""
    echo "📋 Available branches in repository:"
    echo "════════════════════════════════════════════════════════════════"
    
    local i=1
    local temp_file=$(mktemp)
    echo "$all_branches" > "$temp_file"
    
    while IFS= read -r branch; do
      if [ -n "$branch" ]; then
        # Check if this is a dotproj branch
        if [[ "$branch" == dotproj-* ]]; then
          echo "  $i) $branch ⭐ (DotProj branch)"
        else
          echo "  $i) $branch"
        fi
        i=$((i + 1))
      fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo ""
    echo "💡 Choose a branch to restore configuration from:"
    echo "   • DotProj branches (⭐) contain project-specific configurations"
    echo "   • Other branches may contain different setups or shared configs"
    echo ""
    
    # Loop until valid selection is made
    while true; do
      echo -n "Select branch number (required): "
      read -r branch_choice
      
      if [ -n "$branch_choice" ] && [ "$branch_choice" -gt 0 ] 2>/dev/null; then
        selected_branch=$(echo "$all_branches" | sed -n "${branch_choice}p")
        if [ -n "$selected_branch" ]; then
          echo "  ✅ Selected branch: $selected_branch"
          branch_name="$selected_branch"
          break
        else
          echo "  ❌ Invalid selection. Please choose a number from the list above."
          echo ""
        fi
      else
        echo "  ❌ Please enter a valid number from the list above."
        echo ""
      fi
    done
  else
    echo "  ⚠️  No branches found in repository. Using default: $branch_name"
  fi
  
  echo "🔀 Setting up project branch: $branch_name"
  
  # Check if the selected branch exists on remote
  if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
    echo "  📥 Checking out existing remote branch: $branch_name"
    git checkout -q "$branch_name"
  elif git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "  🔄 Switching to existing local branch: $branch_name"
    git checkout -q "$branch_name"
  else
    # Get the default branch (could be main, master, etc.)
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "")
    
    if [ -z "$default_branch" ]; then
      # Fallback: try to determine default branch from available branches
      default_branch=$(git branch -r | grep -E 'origin/(main|master)' | head -1 | sed 's@.*origin/@@' | tr -d ' ' || echo "")
    fi
    
    if [ -z "$default_branch" ]; then
      # Final fallback: use current branch
      default_branch=$(git branch --show-current 2>/dev/null || echo "main")
    fi
    
    echo "  🆕 Creating new project branch: $branch_name (from $default_branch)"
    git checkout -q -b "$branch_name" "$default_branch" 2>/dev/null || git checkout -q -b "$branch_name"
  fi

  # Write configuration
  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  write_config "$PROJECT" "git" "$git_repo"
  write_config "$PROJECT" "branch" "$branch_name"

  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"

  echo ""
  echo "🎯 Repository cloned and branch '$branch_name' selected!"
  echo ""
  echo "💡 Next steps:"
  echo "   1. Review the files in the selected branch"
  echo "   2. Run 'dotproj commit $PROJECT' to apply files as symlinks"
  echo "   3. Or run 'dotproj status $PROJECT' to see what will be applied"
  echo ""
  echo -n "Apply files from '$branch_name' to current project now? (y/N): "
  read -r apply_now
  
  if [ "$apply_now" = "y" ] || [ "$apply_now" = "Y" ]; then
    echo ""
    echo "🔗 Committing files/dotfiles to current project..."
    
    # Apply all files from the repository as symlinks
    local dotfiles_applied=0
    find "$project_dir" -type f -not -path "*/.git/*" -not -name ".gitignore" | while IFS= read -r stored_file; do
      # Calculate relative path from project_dir
      rel_path="${stored_file#$project_dir/}"
      
      # Skip dotfiles directory prefix if it exists
      if [[ "$rel_path" == dotfiles/* ]]; then
        rel_path="${rel_path#dotfiles/}"
      fi
      
      target_file="$project_path/$rel_path"
      
      mkdir -p "$(dirname "$target_file")"
      create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
      echo "    🔗 Committed: $rel_path"
      dotfiles_applied=$((dotfiles_applied + 1))
    done

    if [ $dotfiles_applied -eq 0 ]; then
      echo "  ⚠️  No files found to commit from the repository"
    fi

    echo ""
    echo "🎉 Clone and commit complete!"
  else
    echo ""
    echo "🎉 Clone complete!"
    echo "   Files are ready in branch '$branch_name'"
    echo "   Run 'dotproj commit $PROJECT' when ready to apply them"
  fi
  echo ""
  echo "💡 Project details:"
  echo "   Name:    $PROJECT"
  echo "   Storage: $project_dir"
  echo "   Target:  $project_path"
  echo "   Remote:  $git_repo"
  echo ""
  echo "📋 Available commands:"
  echo "   dotproj status $PROJECT    - Show committed files"
  echo "   dotproj add $PROJECT       - Add more files"
  echo "   dotproj commit $PROJECT    - Apply any new files as symlinks"
  echo "   dotproj push $PROJECT      - Push changes to remote"
  echo "   dotproj pull $PROJECT      - Pull changes from remote"
}

add() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    echo "Run 'dotproj init $PROJECT' first to create the project"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    exit 1
  fi

  echo "🔄 Adding files/dotfiles to existing project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  
  echo "Currently tracked files/dotfiles:"
  if [ -d "$project_dir/dotfiles" ] && [ "$(find "$project_dir/dotfiles" -type f | wc -l)" -gt 0 ]; then
    find "$project_dir/dotfiles" -type f | while IFS= read -r file; do
      rel_path="${file#$project_dir/dotfiles/}"
      echo "  ✅ $rel_path"
    done
  else
    echo "  (none)"
  fi
  
  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  # Create symlinks for newly added files
  local dotfiles_dir="$project_dir/dotfiles"
  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo ""
    echo "🔗 Committing newly added files/dotfiles..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      # Only create symlink if target doesn't exist or isn't already correctly linked
      if [ ! -L "$target_file" ] || [ "$(readlink "$target_file" 2>/dev/null)" != "$stored_file" ]; then
        mkdir -p "$(dirname "$target_file")"
        create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
        echo "    🔗 Committed: $rel_path"
      fi
    done
  fi
  
  cd "$project_dir" || exit 1
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    git checkout -q "$branch_name" 2>/dev/null || git checkout -q -b "$branch_name"
  fi
  
  git add .
  git commit -q -m "Add new files/dotfiles to $PROJECT" 2>/dev/null || echo "No new files to commit"
  
  echo ""
  echo "✅ Successfully added and committed files/dotfiles to '$PROJECT'"
  
  # Check for uncommitted/unpushed changes and show next steps
  check_project_changes "$project_dir" "false"
  local change_status=$?
  
  echo ""
  if [ $change_status -eq 0 ]; then
    echo -e "${GREEN}✅ Your dotfiles are up to date with the remote repository${NC}"
  else
    if [ $((change_status & 1)) -eq 1 ]; then
      echo -e "${RED}⚠️  You have uncommitted changes in your dotfiles${NC}"
    fi
    if [ $((change_status & 2)) -eq 2 ]; then
      echo -e "${RED}⚠️  You have unpushed dotfiles changes${NC}"
    fi
    echo -e "💡 Push your changes to sync with remote: ${CYAN}dotproj push $PROJECT${NC}"
  fi
}

remove() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "🗑️  Remove Project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  echo "This will permanently delete:"
  echo "  - Project storage: $project_dir"
  echo "  - All tracked files/dotfiles for this project"
  echo "  - Configuration entries"
  echo ""
  echo "⚠️  Warning: This action cannot be undone!"
  echo ""
  echo -n "Are you sure you want to remove project '$PROJECT'? (type 'yes' to confirm): "
  read -r confirmation

  if [ "$confirmation" = "yes" ]; then
    rm -rf "$project_dir"
    
    if [ -f "$CONFIG_FILE" ]; then
      grep -v "^$PROJECT:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" 2>/dev/null || true
      mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE" 2>/dev/null || rm -f "${CONFIG_FILE}.tmp"
    fi
    
    echo "✅ Project '$PROJECT' has been successfully removed"
  else
    echo "❌ Project removal cancelled"
  fi
}

commit() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    echo "Set path with 'dotproj init $PROJECT' or edit $CONFIG_FILE"
    exit 1
  fi

  echo "📋 Committing files/dotfiles for '$PROJECT'..."

  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "  Creating symlinks for tracked dotfiles..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      mkdir -p "$(dirname "$target_file")"
      
      create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
      echo "    🔗 Committed: $rel_path -> $stored_file"
    done
  else
    echo "  ℹ️  No files/dotfiles are currently tracked for this project"
    echo "    Use 'dotproj add $PROJECT' to track some files/dotfiles first"
  fi
  
  echo "✅ Committed files/dotfiles for '$PROJECT'"
  echo "✅ Configuration applied successfully and symlinked into your project"
  
  # Check for uncommitted/unpushed changes and show appropriate next steps
  check_project_changes "$project_dir" "false"
  local change_status=$?
  
  echo ""
  if [ $change_status -eq 0 ]; then
    echo -e "${GREEN}✅ Your dotfiles are up to date with the remote repository${NC}"
    echo -e "💡 You can now pull the latest changes: ${CYAN}dotproj pull $PROJECT${NC}"
  else
    if [ $((change_status & 1)) -eq 1 ]; then
      echo -e "${RED}⚠️  You have uncommitted changes in your dotfiles${NC}"
    fi
    if [ $((change_status & 2)) -eq 2 ]; then
      echo -e "${RED}⚠️  You have unpushed dotfiles changes${NC}"
    fi
    echo -e "💡 Push your changes to sync with remote: ${CYAN}dotproj push $PROJECT${NC}"
  fi
}

push() {
  check_project
  check_git
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")
  local branch_name="${stored_branch:-dotproj-$PROJECT}"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "🚀 Pushing files/dotfiles for '$PROJECT'..."
  cd "$project_dir" || exit 1
  
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      echo "  Switching to branch: $branch_name"
      git checkout -q "$branch_name"
    else
      echo "  Creating and switching to branch: $branch_name"
      git checkout -q -b "$branch_name"
    fi
  fi

  echo "  Staging changes..."
  git add .
  if git commit -q -m "Push dotfiles for $PROJECT - $(date '+%Y-%m-%d %H:%M:%S')" 2>/dev/null; then
    echo "  ✅ Changes committed locally"
  else
    echo "  ℹ️  No changes to commit"
  fi

  if [ -n "$git_repo" ]; then
    echo "  🌐 Pushing to remote repository..."
    
    if ! git remote get-url origin >/dev/null 2>&1; then
      echo "  Setting up remote: $git_repo"
      git remote add origin "$git_repo"
    fi

    echo "  Pushing to remote..."
    if git push origin "$branch_name" 2>/dev/null; then
      echo "  ✅ Successfully pushed to remote"
    else
      echo "  ⚠️  Push failed. You may need to pull first to resolve conflicts."
      echo "     Try: dotproj pull $PROJECT"
    fi
  else
    echo "  ℹ️  No remote Git repo configured, local commit only"
    echo "     Set Git repo during 'dotproj init $PROJECT' or edit $CONFIG_FILE"
  fi
  
  echo "✅ Push completed for '$PROJECT'"
}

pull() {
  check_project
  check_git
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")
  local branch_name="${stored_branch:-dotproj-$PROJECT}"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$git_repo" ]; then
    echo "Error: No remote Git repository configured for project '$PROJECT'"
    echo "Configure during 'dotproj init $PROJECT' or edit $CONFIG_FILE"
    exit 1
  fi

  echo "📥 Pulling files/dotfiles for '$PROJECT'..."
  cd "$project_dir" || exit 1
  
  # Check for uncommitted changes before pulling
  check_project_changes "$project_dir" "false"
  local change_status=$?
  if [ $((change_status & 1)) -eq 1 ]; then
    echo ""
    echo -e "${RED}⚠️  Warning: You have uncommitted changes in your dotfiles${NC}"
    echo -e "${YELLOW}   This may cause conflicts during pull operation.${NC}"
    echo ""
    echo -n "Continue anyway? (y/N): "
    read -r continue_choice
    if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
      echo -e "Pull cancelled. Consider running '${CYAN}dotproj push $PROJECT${NC}' first."
      exit 1
    fi
    echo ""
  fi
  
  # Check if there are multiple remote branches available
  local remote_branches
  remote_branches=$(git branch -r 2>/dev/null | sed 's/^[* ] //' | sed 's/origin\///' | grep -v '^HEAD' | sort -u | grep -v '^$' || echo "")
  local remote_branch_count
  remote_branch_count=$(echo "$remote_branches" | wc -l)
  
  # If there are multiple branches, let user choose which one to pull from
  if [ "$remote_branch_count" -gt 1 ] && [ -n "$remote_branches" ]; then
    echo ""
    echo "📋 Available remote branches:"
    echo "════════════════════════════════════════════════════════════════"
    
    local i=1
    local temp_file=$(mktemp)
    echo "$remote_branches" > "$temp_file"
    
    while IFS= read -r branch; do
      if [ -n "$branch" ]; then
        # Check if this is a dotproj branch
        if [[ "$branch" == dotproj-* ]]; then
          echo "  $i) $branch ⭐ (DotProj branch)"
        else
          echo "  $i) $branch"
        fi
        i=$((i + 1))
      fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    echo ""
    echo "💡 Choose a branch to pull from:"
    echo "   • DotProj branches (⭐) contain project-specific configurations"
    echo "   • Other branches may contain different setups or shared configs"
    echo ""
    
    # Loop until valid selection is made or user chooses default
    while true; do
      echo -n "Select branch number (or press Enter for current '$branch_name'): "
      read -r branch_choice
      
      if [ -z "$branch_choice" ]; then
        echo "  ℹ️  Using current branch: $branch_name"
        break
      elif [ "$branch_choice" -gt 0 ] 2>/dev/null; then
        local selected_branch
        selected_branch=$(echo "$remote_branches" | sed -n "${branch_choice}p")
        if [ -n "$selected_branch" ]; then
          echo "  ✅ Selected branch: $selected_branch"
          branch_name="$selected_branch"
          # Update stored branch configuration
          write_config "$PROJECT" "branch" "$branch_name"
          break
        else
          echo "  ❌ Invalid selection. Please choose a number from the list above or press Enter for default."
          echo ""
        fi
      else
        echo "  ❌ Please enter a valid number from the list above or press Enter for default."
        echo ""
      fi
    done
  fi
  
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      echo "  Switching to branch: $branch_name"
      git checkout -q "$branch_name"
    else
      echo "  Creating and switching to branch: $branch_name"
      git checkout -q -b "$branch_name"
    fi
  fi

  echo "  Fetching from remote..."
  if git fetch origin 2>/dev/null; then
    if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
      echo "  Merging with remote branch: $branch_name"
      if git merge "origin/$branch_name" --no-edit -q 2>/dev/null; then
        echo "  ✅ Successfully pulled from remote"
        
        # After successful pull, ask if user wants to commit the changes
        echo ""
        echo "💡 Changes pulled successfully. Apply them to your project?"
        echo -n "Run 'dotproj commit $PROJECT' now? (y/N): "
        read -r apply_choice
        if [ "$apply_choice" = "y" ] || [ "$apply_choice" = "Y" ]; then
          echo ""
          commit
        else
          echo "  ℹ️  Run 'dotproj commit $PROJECT' when ready to apply changes"
        fi
      else
        echo "  ⚠️  Merge conflict detected. Please resolve manually:"
        echo "     cd $project_dir"
        echo "     git status"
        echo "     # Resolve conflicts, then:"
        echo "     git add ."
        echo "     git commit"
        echo "     dotproj commit $PROJECT"
        return 1
      fi
    else
      echo "  ⚠️  Remote branch '$branch_name' not found"
      echo "     The remote repository may not have this project branch yet"
      echo "     Try: dotproj push $PROJECT"
    fi
  else
    echo "  ❌ Failed to fetch from remote"
    echo "     Please check your repository access and internet connection"
    return 1
  fi
  
  echo "✅ Pull completed for '$PROJECT'"
}

status() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local stored_branch
  stored_branch=$(get_project_config "$PROJECT" "branch")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "📊 Status for project '$PROJECT'"
  echo "════════════════════════════════════════════════════════════════"
  echo "Project path: $project_path"
  echo "Storage path: $project_dir"
  [ -n "$git_repo" ] && echo "Git repo: $git_repo" || echo "Git repo: (not configured)"
  [ -n "$stored_branch" ] && echo "Git branch: $stored_branch" || echo "Git branch: dotproj-$PROJECT (default)"
  echo ""

  # Check for uncommitted/unpushed changes
  check_project_changes "$project_dir" "true"
  local change_status=$?
  if [ $change_status -gt 0 ]; then
    echo ""
  fi

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "📁 Tracked dotfiles:"
    find "$dotfiles_dir" -type f | while IFS= read -r file; do
      rel_path="${file#$dotfiles_dir/}"
      echo "  ✅ $rel_path"
    done
  else
    echo "📁 No dotfiles are currently tracked."
    echo "    Use 'dotproj add $PROJECT' to add some dotfiles."
  fi

  echo ""
  echo "💡 Available commands:"
  echo "    dotproj add $PROJECT       - Add more dotfiles"
  echo "    dotproj commit $PROJECT    - Apply dotfiles as symlinks to project"
  echo "    dotproj push $PROJECT      - Push changes to Git repository"
  echo "    dotproj pull $PROJECT      - Pull latest changes from Git repository"
}

list() {
  local show_all="$1"
  local current_dir="$PWD"
  
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "No projects found. Run 'dotproj init <project>' to create one."
    return
  fi

  if [ "$show_all" = "all" ]; then
    echo "All projects:"
    grep '^[^:]*:dotfiles:' "$CONFIG_FILE" | cut -d':' -f1 | sort -u | while read -r proj; do
      local proj_path
      proj_path=$(get_project_config "$proj" "path")
      echo "- $proj → $proj_path"
    done
  else
    echo "Projects in current directory ($current_dir):"
    local found_projects=0
    grep '^[^:]*:dotfiles:' "$CONFIG_FILE" | cut -d':' -f1 | sort -u | while read -r proj; do
      local proj_path
      proj_path=$(get_project_config "$proj" "path")
      if [ "$proj_path" = "$current_dir" ]; then
        echo "- $proj"
        found_projects=$((found_projects + 1))
      fi
    done
    
    # Check if no projects found in current directory
    if ! grep '^[^:]*:dotfiles:' "$CONFIG_FILE" | cut -d':' -f1 | sort -u | while read -r proj; do
      local proj_path
      proj_path=$(get_project_config "$proj" "path")
      if [ "$proj_path" = "$current_dir" ]; then
        exit 0  # Found at least one
      fi
    done; then
      echo "No projects configured for current directory."
      echo "Use 'dotproj list all' to see all projects."
    fi
  fi
}

case "$CMD" in
  setup)
    [ "$2" = "--help" ] && command_help setup
    setup
    ;;
  init)
    [ "$2" = "--help" ] && command_help init
    init
    ;;
  clone)
    [ "$2" = "--help" ] && command_help clone
    clone
    ;;
  add)
    [ "$2" = "--help" ] && command_help add
    add
    ;;
  commit)
    [ "$2" = "--help" ] && command_help commit
    commit
    ;;
  status)
    [ "$2" = "--help" ] && command_help status
    status
    ;;
  push)
    [ "$2" = "--help" ] && command_help push
    push
    ;;
  pull)
    [ "$2" = "--help" ] && command_help pull
    pull
    ;;
  remove)
    [ "$2" = "--help" ] && command_help remove
    remove
    ;;
  list)
    [ "$2" = "--help" ] && command_help list
    list "$2"
    ;;
  version)
    version
    ;;
  # Legacy command support with deprecation warnings
  apply)
    echo "⚠️  DEPRECATED: 'apply' command is deprecated. Use 'commit' instead."
    echo "   Running 'dotproj commit $PROJECT'..."
    echo ""
    commit
    ;;
  sync)
    echo "⚠️  DEPRECATED: 'sync' command is deprecated. Use 'push' instead."
    echo "   Running 'dotproj push $PROJECT'..."
    echo ""
    push
    ;;
  remote)
    echo "⚠️  DEPRECATED: 'remote' command is deprecated. Use 'clone' instead."
    echo "   Running 'dotproj clone $PROJECT'..."
    echo ""
    clone
    ;;
  save)
    echo "⚠️  DEPRECATED: 'save' command is deprecated."
    echo "   With symlinks, changes are automatically saved."
    echo "   Use 'dotproj status $PROJECT' to check file integrity."
    echo ""
    status
    ;;
  --help)
    usage
    ;;
  *)
    usage
    ;;
esac