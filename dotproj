#!/bin/bash

# DotProj CLI - Manages project-specific dotfiles with Git versioning

CONFIG_FILE="$HOME/.dotproj/config"
DOTFILES_ROOT="$HOME/dotfiles/projects"
CMD="$1"
PROJECT="$2"

mkdir -p "$DOTFILES_ROOT"

# Check if Git is available
check_git() {
  if ! command -v git >/dev/null 2>&1; then
    echo "âŒ Error: Git is required but not installed."
    echo ""
    echo "ğŸ“¦ Please install Git first:"
    echo "  â€¢ Ubuntu/Debian: sudo apt update && sudo apt install git"
    echo "  â€¢ CentOS/RHEL:   sudo yum install git"
    echo "  â€¢ Fedora:        sudo dnf install git"
    echo "  â€¢ macOS:         brew install git (or install Xcode Command Line Tools)"
    echo "  â€¢ Arch Linux:    sudo pacman -S git"
    echo ""
    echo "DotProj requires Git for version control and synchronization."
    exit 1
  fi
}

# Check Git configuration and provide setup guidance
check_git_config() {
  local git_name
  local git_email
  
  git_name=$(git config --global user.name 2>/dev/null || echo "")
  git_email=$(git config --global user.email 2>/dev/null || echo "")
  
  if [ -z "$git_name" ] || [ -z "$git_email" ]; then
    echo "âš ï¸  Git is not fully configured for commits."
    echo ""
    echo "ğŸ”§ Please configure Git with your name and email:"
    echo "   git config --global user.name \"Your Name\""
    echo "   git config --global user.email \"your.email@example.com\""
    echo ""
    echo "This is required for Git commits and synchronization."
    echo ""
    echo -n "Continue anyway? (y/N): "
    read -r continue_choice
    if [ "$continue_choice" != "y" ] && [ "$continue_choice" != "Y" ]; then
      echo "Setup cancelled. Please configure Git and try again."
      exit 1
    fi
    echo ""
  fi
}

get_relative_path() {
  local file="$1"
  local project_path="$2"
  echo "${file#$project_path/}"
}

prompt_dotfiles_selection() {
  local project_path="$1"
  local project="$2"
  
  echo ""
  echo "ğŸ“ Dotfiles Selection for '$project'"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "Enter the files/dotfiles/folders you want to track (comma-separated):"
  echo ""
  echo "Examples:"
  echo "  .env.local, .vscode, .cursor, monorepo/front-end/.cursor, monorepo/back-end/.env"
  echo "  .eslintrc.json, .prettierrc, .gitignore"
  echo ""
  echo "ğŸ’¡ Tips:"
  echo "  - Use relative paths from your project root"
  echo "  - Folders will include all files within them"
  echo "  - You can add more dotfiles later with 'dotproj add <project>'"
  echo ""
  echo -n "Enter dotfiles to track (or press Enter to skip): "
  read -r dotfiles_input
  
  if [ -n "$dotfiles_input" ]; then
    echo "$dotfiles_input" | tr ',' '\n' | while IFS= read -r item; do
      item=$(echo "$item" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      
      if [ -n "$item" ]; then
        full_path="$project_path/$item"
        
        if [ -e "$full_path" ]; then
          if [ -d "$full_path" ]; then
            find "$full_path" -type f | while IFS= read -r file; do
              link_dotfile "$file" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
              rel_path=$(get_relative_path "$file" "$project_path")
              echo "  âœ… Added: $rel_path"
            done
          else
            link_dotfile "$full_path" "$DOTFILES_ROOT/$project/dotfiles" "$project_path"
            echo "  âœ… Added: $item"
          fi
        else
          echo "  âš ï¸  Warning: $item not found in project directory"
        fi
      fi
    done
  else
    echo "  â„¹ï¸  No dotfiles selected. You can add them later with 'dotproj add <project>'"
  fi
}

is_tracked() {
  local file="$1"
  local project="$2"
  local dotfiles_dir="$DOTFILES_ROOT/$project/dotfiles"
  local tracked_file="$dotfiles_dir/$file"
  
  [ -f "$tracked_file" ]
}

link_dotfile() {
  local src_file="$1"
  local dest_dir="$2"
  local project_path="$3"
  
  local rel_path
  rel_path=$(get_relative_path "$src_file" "$project_path")
  local dest_file="$dest_dir/$rel_path"
  
  mkdir -p "$(dirname "$dest_file")"
  cp "$src_file" "$dest_file"
}

create_symlink() {
  local stored_file="$1"
  local target_file="$2"
  local rel_path="$3"
  local project_dir="$4"
  
  # Create backup if target exists and is not already a symlink to our stored file
  if [ -e "$target_file" ]; then
    if [ -L "$target_file" ]; then
      # Check if it's already pointing to our stored file
      if [ "$(readlink "$target_file")" = "$stored_file" ]; then
        return 0  # Already correctly linked
      else
        # Symlink pointing elsewhere, back it up
        local backup_dir="$project_dir/backups"
        mkdir -p "$backup_dir"
        local backup_file="$backup_dir/${rel_path//\//_}.backup"
        
        # Remove existing backup if it exists, then create new one
        [ -e "$backup_file" ] && rm -f "$backup_file"
        mv "$target_file" "$backup_file"
        echo "    ğŸ“¦ Updated backup for symlink: $rel_path -> backups/${backup_file##*/}"
      fi
    else
      # Regular file, back it up
      local backup_dir="$project_dir/backups"
      mkdir -p "$backup_dir"
      local backup_file="$backup_dir/${rel_path//\//_}.backup"
      
      # Remove existing backup if it exists, then create new one
      [ -e "$backup_file" ] && rm -f "$backup_file"
      cp "$target_file" "$backup_file"
      rm "$target_file"
      echo "    ğŸ“¦ Updated backup for file: $rel_path -> backups/${backup_file##*/}"
    fi
  fi
  
  # Create the symlink
  ln -s "$stored_file" "$target_file"
}

ensure_gitignore() {
  local project_dir="$1"
  local gitignore_file="$project_dir/.gitignore"
  
  # Create .gitignore if it doesn't exist
  if [ ! -f "$gitignore_file" ]; then
    touch "$gitignore_file"
  fi
  
  # Add backups directory to .gitignore if not already there
  if ! grep -q "^backups/" "$gitignore_file" 2>/dev/null; then
    echo "" >> "$gitignore_file"
    echo "# DotProj backup files" >> "$gitignore_file"
    echo "backups/" >> "$gitignore_file"
    echo "  â„¹ï¸  Added backups/ to .gitignore"
  fi
}

usage() {
  echo "DotProj CLI - Manage project-specific dotfiles"
  echo "Usage: dotproj <command> [project]"
  echo "Commands:"
  echo "  setup               Install DotProj and add to PATH"
  echo "  init <project>      Initialize dotfiles for a project"
  echo "  remote <project>    Initialize from a remote dotproj repository"
  echo "  add <project>       Add more dotfiles to an existing project"
  echo "  apply <project>     Apply dotfiles as symlinks to the current environment"
  echo "  save <project>      Check dotfile symlink integrity (changes auto-saved)"
  echo "  sync <project>      Commit and push/pull dotfiles to/from Git repo"
  echo "  remove <project>    Remove a project and all its dotfiles"
  echo "  list                List all projects"
  echo "  status <project>    Show tracked and excluded dotfiles for a project"
  echo "  version             Show version and system information"
  echo "Use 'dotproj <command> --help' for more details"
  exit 1
}

version() {
  echo "ğŸ¯ DotProj - Project-Specific Dotfiles Manager"
  echo "Version: 1.0.0"
  echo ""
  echo "ğŸ“‹ System Information:"
  echo "  OS: $(uname -s)"
  echo "  Shell: $SHELL"
  if command -v git >/dev/null 2>&1; then
    echo "  Git: $(git --version)"
    local git_name git_email
    git_name=$(git config --global user.name 2>/dev/null || echo "Not configured")
    git_email=$(git config --global user.email 2>/dev/null || echo "Not configured")
    echo "  Git User: $git_name <$git_email>"
  else
    echo "  Git: âŒ Not installed"
  fi
  echo ""
  echo "ğŸ“ DotProj Paths:"
  echo "  Config: $CONFIG_FILE"
  echo "  Storage: $DOTFILES_ROOT"
}

command_help() {
  local cmd="$1"
  case "$cmd" in
    setup)
      echo "dotproj setup: Installs DotProj and adds it to PATH"
      echo "Adds ~/.dotproj/dotproj.sh to ~/.bashrc or ~/.zshrc"
      ;;
    init)
      echo "dotproj init <project>: Initializes dotfiles for a project"
      echo "Creates project storage and prompts for dotfiles selection"
      echo "Prompts for project path and optional Git repo"
      ;;
    remote)
      echo "dotproj remote <project>: Initialize from a remote dotproj repository"
      echo "Clones the repository and sets up the project with all dotfiles"
      echo "Usage: dotproj remote <project> [git-repo-url]"
      echo "If no URL provided, will prompt for repository URL"
      ;;
    add)
      echo "dotproj add <project>: Add more dotfiles to an existing project"
      echo "Allows you to track additional dotfiles using comma-separated input"
      ;;
    apply)
      echo "dotproj apply <project>: Applies dotfiles to the environment"
      echo "Creates symlinks from project locations to stored dotfiles"
      ;;
    save)
      echo "dotproj save <project>: Checks dotfile symlink integrity"
      echo "With symlinks, changes are automatically reflected in storage"
      ;;
    sync)
      echo "dotproj sync <project>: Syncs dotfiles with Git"
      echo "Commits changes and pushes/pulls to/from remote repo (if configured)"
      ;;
    remove)
      echo "dotproj remove <project>: Remove a project and all its dotfiles"
      echo "Permanently deletes the project storage directory"
      ;;
    list)
      echo "dotproj list: Lists all initialized projects"
      ;;
    status)
      echo "dotproj status <project>: Shows tracked dotfiles for a project"
      echo "Displays which files are being managed"
      ;;
    version)
      echo "dotproj version: Shows version and system information"
      echo "Displays DotProj version, Git status, and configuration paths"
      ;;
    *)
      usage
      ;;
  esac
  exit 0
}

check_project() {
  if [ -z "$PROJECT" ]; then
    echo "Error: Project name required"
    usage
  fi
}

get_project_config() {
  local project="$1"
  local key="$2"
  if [ -f "$CONFIG_FILE" ]; then
    grep "^$project:$key:" "$CONFIG_FILE" | cut -d':' -f3-
  fi
}

write_config() {
  local project="$1"
  local key="$2"
  local value="$3"
  mkdir -p "$(dirname "$CONFIG_FILE")"
  if [ -f "$CONFIG_FILE" ]; then
    grep -v "^$project:$key:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" || true
    mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
  fi
  echo "$project:$key:$value" >> "$CONFIG_FILE"
}

setup() {
  check_git
  
  # Create dotproj directory
  mkdir -p "$HOME/.dotproj"
  
  # Install the script with proper naming
  if [ -f "$HOME/.dotproj/dotproj" ]; then
    echo "DotProj already installed at ~/.dotproj/dotproj"
  else
    echo "Installing DotProj to ~/.dotproj/dotproj..."
    cp "$0" "$HOME/.dotproj/dotproj"
    chmod +x "$HOME/.dotproj/dotproj"
  fi

  # Add to PATH if not already there
  shell_file="$HOME/.bashrc"
  [ -f "$HOME/.zshrc" ] && shell_file="$HOME/.zshrc"
  
  if ! grep -q "PATH.*\.dotproj" "$shell_file"; then
    echo "Adding DotProj to PATH in $shell_file..."
    echo '' >> "$shell_file"
    echo '# DotProj - Project-specific dotfiles manager' >> "$shell_file"
    echo 'export PATH="$HOME/.dotproj:$PATH"' >> "$shell_file"
    echo "âœ… Added to PATH. Please restart your terminal or run: source $shell_file"
  else
    echo "âœ… DotProj already in PATH"
  fi
  
  echo "ğŸ‰ Setup complete! Run 'dotproj --help' for available commands"
}

init() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' already exists in $project_dir"
    exit 1
  fi

  echo "Enter project path (default: $PWD):"
  read -r project_path
  project_path="${project_path:-$PWD}"
  if [ ! -d "$project_path" ]; then
    echo "Error: Directory $project_path does not exist"
    exit 1
  fi

  echo ""
  echo "ğŸ”— Git Repository (Optional)"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "Enter Git repository URL to sync your dotfiles across machines:"
  echo ""
  echo "Examples:"
  echo "  https://github.com/username/project-dotfiles.git"
  echo "  git@gitlab.com:username/project-dotfiles.git"
  echo "  https://bitbucket.org/username/project-dotfiles.git"
  echo ""
  echo -n "Git repo URL (press Enter to skip): "
  read -r git_repo

  echo "Creating project structure..."
  mkdir -p "$project_dir/dotfiles"

  echo "Initializing Git repo..."
  cd "$project_dir" || exit 1
  git init -q
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  git checkout -q -b "$branch_name"
  
  git add .
  git commit -q -m "Initial dotfiles for $PROJECT"

  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  [ -n "$git_repo" ] && write_config "$PROJECT" "git" "$git_repo"
  echo "Initialized project '$PROJECT' in $project_dir"

  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  cd "$project_dir" || exit 1
  git add .
  git commit -q -m "Add selected dotfiles for $PROJECT"
}

remote() {
  check_project
  check_git
  check_git_config
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo="$3"

  if [ -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' already exists in $project_dir"
    exit 1
  fi

  # Get Git repository URL if not provided
  if [ -z "$git_repo" ]; then
    echo ""
    echo "ğŸŒ Remote DotProj Repository"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Enter the Git repository URL containing the dotproj configuration:"
    echo ""
    echo "Examples:"
    echo "  https://github.com/username/my-dotfiles.git"
    echo "  git@github.com:username/my-dotfiles.git"
    echo "  https://gitlab.com/username/project-config.git"
    echo ""
    echo -n "Git repo URL: "
    read -r git_repo
    
    if [ -z "$git_repo" ]; then
      echo "Error: Git repository URL is required"
      exit 1
    fi
  fi

  echo ""
  echo "ğŸ¯ Initializing '$PROJECT' from remote repository..."
  echo "Repository: $git_repo"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # Get project path
  echo "Enter project path where dotfiles should be applied (default: $PWD):"
  read -r project_path
  project_path="${project_path:-$PWD}"
  if [ ! -d "$project_path" ]; then
    echo "Error: Directory $project_path does not exist"
    exit 1
  fi

  echo "ğŸ“¥ Cloning remote repository..."
  local temp_dir="/tmp/dotproj-remote-$$"
  
  # Clone the repository
  if ! git clone "$git_repo" "$temp_dir" 2>/dev/null; then
    echo "âŒ Failed to clone repository: $git_repo"
    echo ""
    echo "Please check:"
    echo "  - Repository URL is correct"
    echo "  - You have access to the repository"
    echo "  - Repository exists and is accessible"
    echo "  - Your internet connection is working"
    echo "  - Git is properly configured with credentials (if private repo)"
    echo ""
    echo "ğŸ’¡ For private repositories, you may need to:"
    echo "   - Set up SSH keys: https://docs.github.com/en/authentication/connecting-to-github-with-ssh"
    echo "   - Or use personal access tokens for HTTPS"
    exit 1
  fi

  echo "ğŸ” Analyzing remote repository structure..."
  
  # Check if it's a valid dotproj repository
  if [ ! -d "$temp_dir/dotfiles" ]; then
    echo "âŒ This doesn't appear to be a valid dotproj repository"
    echo "Expected structure: repository/dotfiles/"
    echo "Current structure:"
    ls -la "$temp_dir"
    rm -rf "$temp_dir"
    exit 1
  fi

  echo "âœ… Valid dotproj repository found!"
  
  # Create the project structure
  echo "ğŸ“ Creating project structure..."
  mkdir -p "$project_dir"
  
  # Copy the entire repository to the project directory
  cp -r "$temp_dir/." "$project_dir/"
  
  # Ensure we're on the correct branch
  cd "$project_dir" || exit 1
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  
  # Check if the remote has a branch with our project name, otherwise use current branch
  if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
    echo "ğŸ”€ Switching to project branch: $branch_name"
    git checkout -q "$branch_name"
  elif git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "ğŸ”€ Switching to existing local branch: $branch_name"
    git checkout -q "$branch_name"
  else
    # Create a new branch from current branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "main")
    echo "ğŸ†• Creating new project branch: $branch_name (from $current_branch)"
    git checkout -q -b "$branch_name"
  fi

  # Write configuration
  write_config "$PROJECT" "dotfiles" "$project_dir"
  write_config "$PROJECT" "path" "$project_path"
  write_config "$PROJECT" "git" "$git_repo"

  echo "âœ… Successfully initialized '$PROJECT' from remote repository"
  echo ""

  # Show what was loaded
  echo "ğŸ“‹ Loaded dotfiles:"
  if [ -d "$project_dir/dotfiles" ] && [ "$(find "$project_dir/dotfiles" -type f | wc -l)" -gt 0 ]; then
    find "$project_dir/dotfiles" -type f | while IFS= read -r file; do
      rel_path="${file#$project_dir/dotfiles/}"
      echo "  âœ… $rel_path"
    done
  else
    echo "  âš ï¸  No dotfiles found in the repository"
  fi

  echo ""
  echo "ğŸ‰ Remote initialization complete!"
  echo ""
  echo "ğŸ“‹ Next steps:"
  echo "  1. Review loaded dotfiles: dotproj status $PROJECT"
  echo "  2. Apply to your project: dotproj apply $PROJECT"
  echo "  3. Make changes and save: dotproj save $PROJECT"
  echo "  4. Sync with remote: dotproj sync $PROJECT"
  echo ""
  echo "ğŸ’¡ Project details:"
  echo "   Storage: $project_dir"
  echo "   Target:  $project_path"
  echo "   Remote:  $git_repo"

  # Clean up
  rm -rf "$temp_dir"
}

add() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    echo "Run 'dotproj init $PROJECT' first to create the project"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    exit 1
  fi

  echo "ğŸ”„ Adding dotfiles to existing project '$PROJECT'"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  
  echo "Currently tracked dotfiles:"
  if [ -d "$project_dir/dotfiles" ] && [ "$(find "$project_dir/dotfiles" -type f | wc -l)" -gt 0 ]; then
    find "$project_dir/dotfiles" -type f | while IFS= read -r file; do
      rel_path="${file#$project_dir/dotfiles/}"
      echo "  âœ… $rel_path"
    done
  else
    echo "  (none)"
  fi
  
  prompt_dotfiles_selection "$project_path" "$PROJECT"
  
  # Create symlinks for newly added files
  local dotfiles_dir="$project_dir/dotfiles"
  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo ""
    echo "ğŸ”— Creating symlinks for newly added files..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      # Only create symlink if target doesn't exist or isn't already correctly linked
      if [ ! -L "$target_file" ] || [ "$(readlink "$target_file" 2>/dev/null)" != "$stored_file" ]; then
        mkdir -p "$(dirname "$target_file")"
        create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
        echo "    ğŸ”— Linked: $rel_path"
      fi
    done
  fi
  
  cd "$project_dir" || exit 1
  
  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"
  
  local branch_name="dotproj-$PROJECT"
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    git checkout -q "$branch_name" 2>/dev/null || git checkout -q -b "$branch_name"
  fi
  
  git add .
  git commit -q -m "Add new dotfiles to $PROJECT" 2>/dev/null || echo "No new files to commit"
  
  echo ""
  echo "âœ… Successfully added and linked dotfiles to '$PROJECT'"
}

remove() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "ğŸ—‘ï¸  Remove Project '$PROJECT'"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "This will permanently delete:"
  echo "  - Project storage: $project_dir"
  echo "  - All tracked dotfiles for this project"
  echo "  - Configuration entries"
  echo ""
  echo "âš ï¸  Warning: This action cannot be undone!"
  echo ""
  echo -n "Are you sure you want to remove project '$PROJECT'? (type 'yes' to confirm): "
  read -r confirmation

  if [ "$confirmation" = "yes" ]; then
    rm -rf "$project_dir"
    
    if [ -f "$CONFIG_FILE" ]; then
      grep -v "^$PROJECT:" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" 2>/dev/null || true
      mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE" 2>/dev/null || rm -f "${CONFIG_FILE}.tmp"
    fi
    
    echo "âœ… Project '$PROJECT' has been successfully removed"
  else
    echo "âŒ Project removal cancelled"
  fi
}

apply() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    echo "Set path with 'dotproj init $PROJECT' or edit $CONFIG_FILE"
    exit 1
  fi

  echo "ğŸ“‹ Applying dotfiles for '$PROJECT'..."

  # Ensure .gitignore excludes backups
  ensure_gitignore "$project_dir"

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "  Creating symlinks for tracked dotfiles..."
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      mkdir -p "$(dirname "$target_file")"
      
      create_symlink "$stored_file" "$target_file" "$rel_path" "$project_dir"
      echo "    ğŸ”— Linked: $rel_path -> $stored_file"
    done
  else
    echo "  â„¹ï¸  No dotfiles are currently tracked for this project"
    echo "    Use 'dotproj add $PROJECT' to track some dotfiles first"
  fi
  
  echo "âœ… Applied dotfiles for '$PROJECT'"
}

save() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  if [ -z "$project_path" ] || [ ! -d "$project_path" ]; then
    echo "Error: Project path not configured or invalid"
    exit 1
  fi

  echo "ğŸ’¾ Checking dotfiles for '$PROJECT'..."

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "  â„¹ï¸  With symlinks, changes are automatically saved to storage"
    echo "  Verifying symlink integrity..."
    
    local broken_links=0
    find "$dotfiles_dir" -type f | while IFS= read -r stored_file; do
      rel_path="${stored_file#$dotfiles_dir/}"
      target_file="$project_path/$rel_path"
      
      if [ -L "$target_file" ]; then
        if [ "$(readlink "$target_file")" = "$stored_file" ]; then
          echo "    âœ… Linked: $rel_path"
        else
          echo "    âš ï¸  Warning: $rel_path points to $(readlink "$target_file")"
          broken_links=$((broken_links + 1))
        fi
      elif [ -f "$target_file" ]; then
        echo "    âš ï¸  Warning: $rel_path is a regular file, not a symlink"
        broken_links=$((broken_links + 1))
      else
        echo "    âŒ Missing: $rel_path no longer exists in project"
        broken_links=$((broken_links + 1))
      fi
    done
    
    if [ $broken_links -gt 0 ]; then
      echo "  ğŸ’¡ Run 'dotproj apply $PROJECT' to fix broken or missing links"
    fi
  else
    echo "  â„¹ï¸  No dotfiles are currently tracked for this project"
    echo "    Use 'dotproj add $PROJECT' to track some dotfiles"
  fi
  
  echo "âœ… Dotfiles check completed for '$PROJECT'"
}

sync() {
  check_project
  check_git
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")
  local branch_name="dotproj-$PROJECT"

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "ğŸ”„ Syncing dotfiles for '$PROJECT'..."
  cd "$project_dir" || exit 1
  
  current_branch=$(git branch --show-current 2>/dev/null || echo "")
  if [ "$current_branch" != "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      echo "  Switching to branch: $branch_name"
      git checkout -q "$branch_name"
    else
      echo "  Creating and switching to branch: $branch_name"
      git checkout -q -b "$branch_name"
    fi
  fi

  echo "  Committing changes..."
  git add .
  if git commit -q -m "Sync dotfiles for $PROJECT - $(date '+%Y-%m-%d %H:%M:%S')" 2>/dev/null; then
    echo "  âœ… Changes committed"
  else
    echo "  â„¹ï¸  No changes to commit"
  fi

  if [ -n "$git_repo" ]; then
    echo "  ğŸŒ Syncing with remote repository..."
    
    if ! git remote get-url origin >/dev/null 2>&1; then
      echo "  Setting up remote: $git_repo"
      git remote add origin "$git_repo"
    fi

    echo "  Fetching from remote..."
    if git fetch origin 2>/dev/null; then
      if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        echo "  Merging with remote branch: $branch_name"
        if ! git merge "origin/$branch_name" --no-edit -q 2>/dev/null; then
          echo "  âš ï¸  Merge conflict detected. Please resolve manually:"
          echo "     cd $project_dir"
          echo "     git status"
          echo "     # Resolve conflicts, then:"
          echo "     git add ."
          echo "     git commit"
          echo "     dotproj sync $PROJECT"
          return 1
        fi
      else
        echo "  Setting upstream for new branch: $branch_name"
        git push -u origin "$branch_name" 2>/dev/null || {
          echo "  âš ï¸  Failed to push new branch. The remote may be empty or have permission issues."
          echo "     Please check your repository access and try again."
          return 1
        }
      fi
    else
      echo "  Remote appears to be empty, pushing initial content..."
      if git push -u origin "$branch_name" 2>/dev/null; then
        echo "  âœ… Successfully pushed to new remote repository"
      else
        echo "  âš ï¸  Failed to push to remote. Please check:"
        echo "     - Repository URL: $git_repo"
        echo "     - Your access permissions"
        echo "     - Repository exists and is accessible"
        return 1
      fi
    fi

    echo "  Pushing local changes..."
    if git push origin "$branch_name" 2>/dev/null; then
      echo "  âœ… Successfully synced with remote"
    else
      echo "  âš ï¸  Push failed. You may need to pull and resolve conflicts first."
    fi
  else
    echo "  â„¹ï¸  No remote Git repo configured, local commit only"
    echo "     Set Git repo during 'dotproj init $PROJECT' or edit $CONFIG_FILE"
  fi
  
  echo "âœ… Sync completed for '$PROJECT'"
}

status() {
  check_project
  local project_dir="$DOTFILES_ROOT/$PROJECT"
  local dotfiles_dir="$project_dir/dotfiles"
  local project_path
  project_path=$(get_project_config "$PROJECT" "path")
  local git_repo
  git_repo=$(get_project_config "$PROJECT" "git")

  if [ ! -d "$project_dir" ]; then
    echo "Error: Project '$PROJECT' not found in $DOTFILES_ROOT"
    exit 1
  fi

  echo "ğŸ“Š Status for project '$PROJECT'"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "Project path: $project_path"
  echo "Storage path: $project_dir"
  [ -n "$git_repo" ] && echo "Git repo: $git_repo" || echo "Git repo: (not configured)"
  echo ""

  if [ -d "$dotfiles_dir" ] && [ "$(find "$dotfiles_dir" -type f | wc -l)" -gt 0 ]; then
    echo "ğŸ“ Tracked dotfiles:"
    find "$dotfiles_dir" -type f | while IFS= read -r file; do
      rel_path="${file#$dotfiles_dir/}"
      echo "  âœ… $rel_path"
    done
  else
    echo "ğŸ“ No dotfiles are currently tracked."
    echo "    Use 'dotproj add $PROJECT' to add some dotfiles."
  fi

  echo ""
  echo "ğŸ’¡ Available commands:"
  echo "    dotproj add $PROJECT     - Add more dotfiles"
  echo "    dotproj save $PROJECT    - Check symlink integrity (changes auto-saved)"
  echo "    dotproj apply $PROJECT   - Apply dotfiles as symlinks to project"
  echo "    dotproj sync $PROJECT    - Sync with Git repository"
}

list() {
  if [ -f "$CONFIG_FILE" ]; then
    echo "Available projects:"
    grep '^[^:]*:dotfiles:' "$CONFIG_FILE" | cut -d':' -f1 | sort -u | while read -r proj; do
      echo "- $proj"
    done
  else
    echo "No projects found. Run 'dotproj init <project>' to create one."
  fi
}

case "$CMD" in
  setup)
    [ "$2" = "--help" ] && command_help setup
    setup
    ;;
  init)
    [ "$2" = "--help" ] && command_help init
    init
    ;;
  remote)
    [ "$2" = "--help" ] && command_help remote
    remote
    ;;
  add)
    [ "$2" = "--help" ] && command_help add
    add
    ;;
  apply)
    [ "$2" = "--help" ] && command_help apply
    apply
    ;;
  save)
    [ "$2" = "--help" ] && command_help save
    save
    ;;
  sync)
    [ "$2" = "--help" ] && command_help sync
    sync
    ;;
  remove)
    [ "$2" = "--help" ] && command_help remove
    remove
    ;;
  list)
    [ "$2" = "--help" ] && command_help list
    list
    ;;
  status)
    [ "$2" = "--help" ] && command_help status
    status
    ;;
  version)
    version
    ;;
  --help)
    usage
    ;;
  *)
    usage
    ;;
esac